class Pool
{
    constructor(type, numberToAllocate = 1, allowGrowth = true)
    {
        this.type = type;
        this.numAllocated = numberToAllocate;
        this.allowGrowth = allowGrowth;
        this.numInPool = numberToAllocate;
        this.objects = new Array( numberToAllocate );

        for( let i=0; i<numberToAllocate; i++ )
        {
            this.objects[i] = new type;
        }
    }

    getFromPool()
    {
        if( this.numInPool === 0 )
        {
            console.log( "Pool empty!" );
            if( this.allowGrowth )
            {
                console.log( "Allocating more!" );
                let obj = new this.type();
                return obj;
            }
            else
            {
                return null;
            }
        }

        this.numInPool--;
        return this.objects[this.numInPool];
    }

    returnToPool(obj)
    {
        this.objects[this.numInPool] = obj;
        this.numInPool++;
    }
}

class ImGui
{
    constructor(gl, canvas)
    {
        this.gl = gl;
        this.canvas = canvas;

        // Temp vars to avoid GC.
        this.matProj = new mat4();
        this.buttonString = new String(" ");
        this.largeRect = new ImGuiRect( 0, 0, 10000, 10000 );

        this.vertexAttributesBufferSize = 0;
        this.vertexAttributes = null;
        this.vertexAttributesAsFloats = null;
        this.vertexAttributesAsUint8s = null;
        this.indicesBufferSize = 0;
        this.indices16 = null;
        this.indicesAsUint16s = null;

        // Persistent values.
        this.BGDrawList = [];
        this.FGDrawList = [];
        this.drawList = this.BGDrawList;
        this.windows = {};
        this.frameCount = 0;
        this.currentTime = 0;
        this.ownsMouse = false;
        this.lastTimeMouseClicked = [ 0, 0, 0 ];
        this.mouseDoubleClickedThisFrame = [ false, false, false ];
        this.mouseChange = new vec2(0);
        this.mouseChangeUnscaled = new vec2(0);
        this.lastMousePosition = new vec2(0);
        this.unusedKeyBuffer = null;
        this.mainMenuBarHeight = 0; // How tall is the main menu bar (0 if no bar is active).
        this.activeWindow = null;
        this.previousMenu = null;
        this.activeControl = null;
        this.buttonHeld = null;
        this.controlInEditMode = null;
        this.activeControlTextBuffer = [];
        this.activeControlTextBufferSelected = false; // TODO: Allow only parts of text to be selected and overwritten. and display something.
        this.windowHovered = null;
        this.windowBeingMoved = null;
        this.windowBeingResized = null;
        this.windowResizeOffset = new vec2(0);
        this.windowMoved = false;
        this.oldMouseButtons = [ false, false, false ];
        this.stateIsDirty = false;
        this.font = null;
        this.fontSize = new vec2(0);
        this.activeMenus = {};

        // Colors.
        this.color = {};
        this.color["Title"] =           new color(   0,   0,  50, 255 );
        this.color["BG"] =              new color(   0,   0,  25, 200 );
        this.color["BGBorder"] =        new color( 100, 100, 100, 255 );
        this.color["ButtonNormal"] =    new color(  50,  50, 200, 255 );
        this.color["ButtonHovered"] =   new color(  80,  80, 230, 255 );
        this.color["ButtonPressed"] =   new color( 120, 120, 255, 255 );
        this.color["MenuBar"] =         new color(  30, 100, 200, 255 );
        this.color["MenuPopupBG"] =     new color(   0,   0,   0, 255 );
        this.color["MenuItemNormal"] =  new color(   0,   0,   0,   0 );
        this.color["MenuItemHovered"] = new color(  80,  80,  80, 255 );
        this.color["MenuItemPressed"] = new color( 120, 120, 120, 255 );
        this.color["Checkbox"] =        new color( 196, 196, 196, 255 );
        this.color["TextBoxSelected"] = new color( 100,   0,   0, 255 );
        this.color["TextSelected"] =    new color( 200,  60,   0, 255 );
        this.colorChangeStack = []; // Will hold a pair of ["name", "previous color"] for each overwrite.

        // Persistent values within single frame.

        // Settings.
        this.scale = 2;
        this.padding = new vec2(2);
        this.popupPadding = new vec2(4,5);
        this.doubleClickTime = 0.3;
        this.minDragBoxWidth = 60;

        // Inputs.
        this.mousePosition = new vec2(0);
        this.mouseButtons = [ false, false, false ];
        this.keyBuffer = [];
        
        // Outputs.
        this.isHoveringWindow = false;
        this.isHoveringControl = false;
        this.needsRefresh = false;

        // Resources.
        this.VBO = gl.createBuffer();
        this.IBO = gl.createBuffer();

        let imguiVertShaderSource = `
            attribute vec4 a_Position;
            attribute vec2 a_UV;
            attribute vec4 a_Color;

            uniform mat4 u_MatProj;

            varying vec2 v_UV;
            varying vec4 v_Color;

            void main()
            {
                gl_Position = u_MatProj * a_Position;
                v_UV = a_UV;
                v_Color = a_Color;
            }
        `;

        let imguiFragShaderSource = `
            precision mediump float;

            uniform sampler2D u_TextureAlbedo;

            varying vec2 v_UV;
            varying vec4 v_Color;
            
            void main()
            {
                gl_FragColor = texture2D( u_TextureAlbedo, v_UV ).rrrr * 255.0 * v_Color;
            }
        `;

        this.shader = new Shader( gl, imguiVertShaderSource, imguiFragShaderSource );

        this.fontSize.setF32( 7, 8 );
        this.generateFontTexture();
    }

    generateFontTexture()
    {
        let pixels = new Uint8Array( [
            // Each char is 7x8 + 2 on right and 1 on bottom for padding.
            // Sheet is 13x8 chars ATM, so 117x72 pixels.
            // Dummy full-white block for window backgrounds and other things. 
            // 1 solid BG + 4 unused + 31(blinking cursor) + 32(space) + 33-38: !"#$%&      +    11 chars padding to reach 128 bytes wide.
            1,1,1,1,1,1,1, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,1,0,1,0, 0,0, 0,0,1,0,1,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,1,1,0,0,0,0, 0,0, 0,0,1,1,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            1,1,1,1,1,1,1, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,1,0,1,0, 0,0, 0,0,1,0,1,0,0, 0,0, 0,1,1,1,1,1,1, 0,0, 0,1,1,0,0,0,1, 0,0, 0,1,0,0,1,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            1,1,1,1,1,1,1, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1, 0,0, 0,1,0,0,1,0,0, 0,0, 0,0,0,0,0,1,0, 0,0, 0,1,0,0,1,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            1,1,1,1,1,1,1, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,1,0,1,0,0, 0,0, 0,1,0,0,1,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,1,0,1,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            1,1,1,1,1,1,1, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1, 0,0, 0,1,1,1,1,1,1, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            1,1,1,1,1,1,1, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,1,0,1,0,0, 0,0, 0,0,0,0,1,0,1, 0,0, 0,0,1,0,0,0,0, 0,0, 0,0,1,0,1,0,1, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            1,1,1,1,1,1,1, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,1,0,1,0,0, 0,0, 0,1,1,1,1,1,1, 0,0, 0,1,0,0,0,1,1, 0,0, 0,1,0,0,0,1,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            1,1,1,1,1,1,1, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,1,0,1,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,0,0,1,1, 0,0, 0,0,1,1,1,0,1, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            // 39-51: '()*+,-./00,0,0,0,0,0,0123    0,0,0,0,0,0,0       0,0,0,0,0,0,0       0,0,0,0,0,0,0
            0,0,0,0,1,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,1,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,1,0, 0,0, 0,0,1,1,1,1,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,1,1,1,1,1,1, 0,0, 0,1,1,1,1,1,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,0,1,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,1,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,0,1,1,0,0, 0,0, 0,0,0,0,0,0,1, 0,0, 0,0,0,0,0,0,1, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,0,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,0,0,0,1, 0,0, 0,0,0,0,0,0,1, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,0,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,1,0,1,0,1,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,0,0,1,0,0, 0,0, 0,1,1,1,1,1,1, 0,0, 0,0,1,1,1,1,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,0,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,1,1,1,0,0, 0,0, 0,1,1,1,1,1,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,1,1,1,1,1,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,0,0,1,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,0,0,0,0,0,1, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,0,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,1,0,1,0,1,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,1,1,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,0,0,1,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,0,0,0,0,0,1, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,0,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,1,1,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,1,1,0,0,0, 0,0, 0,0,1,0,0,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,0,0,1,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,0,0,0,0,0,1, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,0,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,1,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,1,1,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,1,1,0,0,0, 0,0, 0,0,1,0,0,0,0, 0,0, 0,0,1,1,1,1,0, 0,0, 0,0,0,1,1,1,0, 0,0, 0,1,1,1,1,1,1, 0,0, 0,1,1,1,1,1,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            // 52-64: 456789:;<=>?@
            0,1,0,0,0,0,1, 0,0, 0,1,1,1,1,1,1, 0,0, 0,1,1,1,1,1,1, 0,0, 0,1,1,1,1,1,1, 0,0, 0,1,1,1,1,1,1, 0,0, 0,1,1,1,1,1,1, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,1,1,0,0, 0,0, 0,0,1,1,1,1,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,0,0,0,0,0,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,0,1,1,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,1, 0,0, 0,0,0,0,0,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,0,1,0,0,1,0, 0,0, 0,1,0,0,0,0,1, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,0,0,0,0,1,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,0,1,1,0,0, 0,0, 0,0,0,1,1,0,0, 0,0, 0,0,0,0,1,1,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,1,1,0,0,0, 0,0, 0,0,0,0,0,0,1, 0,0, 0,1,0,1,1,0,1, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,1,1,1,1,1,1, 0,0, 0,1,1,1,1,1,1, 0,0, 0,1,1,1,1,1,1, 0,0, 0,0,0,0,0,1,0, 0,0, 0,1,1,1,1,1,1, 0,0, 0,1,1,1,1,1,1, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,1,1,0,0, 0,0, 0,0,1,1,0,0,0, 0,0, 0,1,1,1,1,1,0, 0,0, 0,0,0,0,1,1,0, 0,0, 0,0,0,0,0,0,1, 0,0, 0,1,0,1,1,0,1, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,0,0,0,1, 0,0, 0,0,0,0,0,0,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,0,0,1,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,0,0,0,0,1, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,1, 0,0, 0,0,0,0,1,1,0, 0,0, 0,1,0,1,0,0,1, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,0,0,0,1, 0,0, 0,0,0,0,0,0,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,0,0,1,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,0,0,0,0,1, 0,0, 0,0,0,1,1,0,0, 0,0, 0,0,0,1,1,0,0, 0,0, 0,0,1,1,0,0,0, 0,0, 0,1,1,1,1,1,0, 0,0, 0,0,0,0,1,1,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,1,0,0,1,1,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,0,0,0,1, 0,0, 0,0,0,0,0,0,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,0,1,0,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,0,0,0,0,1, 0,0, 0,0,0,1,1,0,0, 0,0, 0,0,0,1,1,0,0, 0,0, 0,0,0,0,1,1,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,1,1,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,0,0,0,1, 0,0, 0,1,1,1,1,1,1, 0,0, 0,1,1,1,1,1,1, 0,0, 0,0,0,1,0,0,0, 0,0, 0,1,1,1,1,1,1, 0,0, 0,0,0,0,0,0,1, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,1,1,0,0,0, 0,0, 0,0,0,0,0,0,1, 0,0, 0,0,0,0,0,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,1,1,1,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            // 65-77: Upper case A-M
            0,0,0,1,1,0,0, 0,0, 0,1,1,1,1,1,0, 0,0, 0,1,1,1,1,1,0, 0,0, 0,1,1,1,1,1,0, 0,0, 0,1,1,1,1,1,1, 0,0, 0,1,1,1,1,1,0, 0,0, 0,1,1,1,1,1,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,1,1,1,1,1, 0,0, 0,0,0,1,1,1,1, 0,0, 0,1,0,0,0,1,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,1,0,0,1,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,0,0,1,0, 0,0, 0,1,0,0,0,1,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,1,0,0,1,1, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,1,0,0,1,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,0,0,1,0, 0,0, 0,1,0,0,1,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,1,1,0,1, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,1,0,0,0,0,1, 0,0, 0,1,1,1,1,1,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,0,0,1,0, 0,0, 0,1,0,1,0,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,1,1,1,1,1,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,1,1,1,1,1, 0,0, 0,1,1,1,1,0,0, 0,0, 0,1,0,0,1,1,1, 0,0, 0,1,1,1,1,1,1, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,0,0,1,0, 0,0, 0,1,1,0,0,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,0,0,1,0, 0,0, 0,1,0,1,0,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,1,0,0,1,0, 0,0, 0,1,0,0,1,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,1,0,0,0,0,1, 0,0, 0,1,1,1,1,1,0, 0,0, 0,1,1,1,1,1,0, 0,0, 0,1,1,1,1,1,0, 0,0, 0,1,1,1,1,1,1, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,1,1,1,1,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,1,1,1,1,1, 0,0, 0,0,0,1,1,0,0, 0,0, 0,1,0,0,0,1,0, 0,0, 0,1,1,1,1,1,0, 0,0, 0,1,0,0,0,0,1, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            // 78-90: Upper case N-Z
            0,1,0,0,0,0,1, 0,0, 0,0,1,1,1,1,0, 0,0, 0,1,1,1,1,1,0, 0,0, 0,0,1,1,1,1,0, 0,0, 0,1,1,1,1,1,0, 0,0, 0,0,1,1,1,1,1, 0,0, 0,0,1,1,1,1,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,1,0,0,0,1, 0,0, 0,1,1,1,1,1,1, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,1,1,0,0,0,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,1,0,0,1,0, 0,0, 0,0,1,0,0,0,1, 0,0, 0,0,0,0,0,0,1, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,1,0,1,0,0,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,1,0,0,1,0, 0,0, 0,0,0,1,0,1,0, 0,0, 0,0,0,0,0,1,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,1,0,0,1,0,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,1,1,1,1,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,1,0,0,1,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,0,1,1,0,0, 0,0, 0,0,0,1,0,1,0, 0,0, 0,0,0,0,1,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,1,0,0,0,1,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,1,1,1,1,0, 0,0, 0,0,1,1,1,1,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,1,0,0,1,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,0,1,1,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,1,0,1, 0,0, 0,1,0,0,1,0,0, 0,0, 0,0,0,0,0,0,1, 0,0, 0,0,0,0,1,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,1,0,0,1,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,1,0,0,1,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,1,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,0,1,1, 0,0, 0,1,0,0,0,1,0, 0,0, 0,0,0,0,0,0,1, 0,0, 0,0,0,0,1,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,1,1,1,1,0, 0,0, 0,1,0,1,1,0,1, 0,0, 0,0,1,0,0,1,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,1,0,0,0,0,1, 0,0, 0,0,1,1,1,1,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,0,1,1,1,1,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,1,1,1,1,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,1,1,1,1,0, 0,0, 0,0,0,1,1,0,0, 0,0, 0,1,1,0,0,1,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,0,0,1,0,0, 0,0, 0,1,1,1,1,1,1, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            // 91-103: [\]^_`abcdefg
            0,0,0,1,1,1,0, 0,0, 0,0,1,0,0,0,0, 0,0, 0,0,1,1,1,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,1,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,1,0,0,0, 0,0, 0,0,1,0,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,1,0,1,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,1,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,1,1,0, 0,0, 0,0,1,1,1,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,1,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,1,0,0,0,1, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,1,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,1,0,0,0,1,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,1,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,1,1,1,0,0, 0,0, 0,1,1,1,1,0,0, 0,0, 0,0,1,1,1,0,0, 0,0, 0,0,1,1,1,1,0, 0,0, 0,0,1,1,1,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,1,0,0,0,1,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,1,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,1,0, 0,0, 0,1,0,0,0,1,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,0,1,0, 0,0, 0,1,0,0,0,1,0, 0,0, 0,0,1,1,1,0,0, 0,0, 0,1,0,0,0,1,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,1,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,1,1,1,0,0, 0,0, 0,1,0,0,0,1,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,0,1,0, 0,0, 0,1,1,1,1,1,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,1,1,1,1,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,1,0,0,0, 0,0, 0,0,0,0,0,1,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,1,0,0,0,1,0, 0,0, 0,1,0,0,0,1,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,0,1,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,0,0,0,1,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,1,1,1,0, 0,0, 0,0,0,0,0,1,0, 0,0, 0,0,1,1,1,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,1,1,1,1,1,1, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,1,1,1,0,1, 0,0, 0,1,1,1,1,0,0, 0,0, 0,0,1,1,1,0,0, 0,0, 0,0,1,1,1,1,0, 0,0, 0,0,1,1,1,1,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,1,1,1,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            // 104-116: hijklmnopqrst
            0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,1,1,1,0,0, 0,0, 0,0,1,1,1,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,1,0,0,0,0,0, 0,0, 0,0,1,0,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,1,0,0,0,1,0, 0,0, 0,1,0,0,0,1,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,1,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,1,0,0,1,0, 0,0, 0,0,1,1,1,0,0, 0,0, 0,0,1,1,1,0,0, 0,0, 0,1,0,0,0,1,0, 0,0, 0,1,0,0,0,1,0, 0,0, 0,1,0,1,1,0,0, 0,0, 0,0,1,1,1,0,0, 0,0, 0,0,1,1,1,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,1,1,1,1,0,0, 0,0, 0,0,1,0,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,1,0,1,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,1,0,1,1,0,1, 0,0, 0,1,0,0,0,1,0, 0,0, 0,1,0,0,0,1,0, 0,0, 0,1,0,0,0,1,0, 0,0, 0,1,0,0,0,1,0, 0,0, 0,1,1,0,0,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,1,0,0,0,1,0, 0,0, 0,0,1,0,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,1,1,0,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,1,0, 0,0, 0,1,0,0,0,1,0, 0,0, 0,1,1,1,1,0,0, 0,0, 0,0,1,1,1,1,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,0,1,1,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,1,0,0,0,1,0, 0,0, 0,0,1,0,0,0,0, 0,0, 0,1,0,0,1,0,0, 0,0, 0,1,0,1,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,1,0, 0,0, 0,1,0,0,0,1,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,0,0,0,0,1,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,1,0,0,0,1,0, 0,0, 0,0,1,0,0,0,0, 0,0, 0,0,1,1,0,0,0, 0,0, 0,1,0,0,1,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,1,0, 0,0, 0,0,1,1,1,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,0,0,0,0,1,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,1,1,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            // 117-129: uvwxyz{|}~ + 3 unused
            0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,1,0,0,0,1,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,1,0,0,0,1,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,1,0,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,0,0,1,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,1,0,0,0,1,0, 0,0, 0,1,0,0,0,1,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,1,0, 0,0, 0,0,1,0,1,0,0, 0,0, 0,1,1,1,1,1,0, 0,0, 0,0,1,0,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,0,0,1,0, 0,0, 0,1,1,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,1,0,0,0,1,0, 0,0, 0,1,0,0,0,1,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,1,0,1,0,0, 0,0, 0,0,1,0,1,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,0,0,0,1, 0,0, 1,0,0,1,0,0,1, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,1,0,0,0,1,0, 0,0, 0,0,1,0,1,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,1,0,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,0,0,1,0, 0,0, 0,0,0,0,1,1,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,1,0,0,0,1,0, 0,0, 0,0,1,0,1,0,0, 0,0, 0,1,0,1,1,0,1, 0,0, 0,0,1,0,1,0,0, 0,0, 0,0,1,0,0,0,0, 0,0, 0,0,1,0,0,0,0, 0,0, 0,0,1,0,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,0,0,1,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,1,1,1,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,1,0,0,1,0, 0,0, 0,1,0,0,0,1,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,1,1,1,1,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            // 130-142: upper-case greek symbols: Δ
            0,0,0,1,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,1,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,1,0,1,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,1,0,1,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,1,0,0,0,1,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,1,0,0,0,1,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            1,0,0,0,0,0,1, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            1,1,1,1,1,1,1, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            // 143-155: lower-case greek symbols: θω
            0,0,0,1,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,1,0,1,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,1,0,0,0,1,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,1,0,0,0,1,0, 0,0, 0,1,0,0,0,1,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,1,1,1,1,1,0, 0,0, 1,0,0,0,0,0,1, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,1,0,0,0,1,0, 0,0, 1,0,0,1,0,0,1, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,1,0,1,0,0, 0,0, 1,0,0,1,0,0,1, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,1,0,0,0, 0,0, 0,1,1,0,1,1,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            // Padding for power of two texture.
            //pixels 90-99
            0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            //pixels 100-109
            0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            //pixels 110-119
            0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            //pixels 120-127
            0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
        ] );

        let texture = new Texture( this.gl );
        let textureRes = new vec2( 128, 128 );
        texture.createFromUInt8Array( pixels, textureRes.x, textureRes.y );

        let firstChar = 33 - 7; // -7 for window BG block + 4 unused spots + 1 blinking cursor (31) + space (32)
        let charSize = new vec2( 7, 8 );
        let gridSize = new vec2( 13, 8 );
        let padding = new vec2( 2, 1 );

        this.font = new FontDef( texture, firstChar, charSize, gridSize, padding, textureRes );
    }

    loadState(imguiState)
    {
        //return;
        let state = null;
        try { state = JSON.parse( imguiState ); }
        catch( e ) { return; }

        this.scale = state.scale;
        this.doubleClickTime = state.doubleClickTime;
        this.minDragBoxWidth = state.minDragBoxWidth;

        for( let key in state.windows )
        {
            this.windows[key] = new ImGuiWindow();
            this.windows[key].name = key;
            let window = this.windows[key];

            window.position.setF32( state.windows[key].position["x"], state.windows[key].position["y"] );
            window.size.setF32( state.windows[key].size["x"], state.windows[key].size["y"] );
            window.cursor.set( window.position );
            window.isMovable = state.windows[key].isMovable;
            window.hasTitle = state.windows[key].hasTitle;
            window.hasFrame = state.windows[key].hasFrame;
            window.takesInput = state.windows[key].takesInput;
            
            // If the window is offscreen, force it back to 0,0.
            if( window.position.x + window.size.x < 0 || window.position.x >= this.canvas.width / this.scale ||
                window.position.y + window.size.y < 0 || window.position.y >= this.canvas.height / this.scale )
            {
                window.position.setF32( 0, 0 );
            }
        }
    }

    markStateDirty()
    {
        this.stateIsDirty = true;
    }

    saveState(storage, name)
    {
        if( this.stateIsDirty )
        {
            //console.log( "Saving imgui state." );

            storage[name] = JSON.stringify( this );
            this.stateIsDirty = false;
        }
    }

    toJSON()
    {
        let state = {
            scale: this.scale,
            doubleClickTime: this.doubleClickTime,
            minDragBoxWidth: this.minDragBoxWidth,
        }

        state.windows = {};
        
        for( let key in this.windows )
        {
            if( this.windows[key].saveState === true )
            {
                state.windows[key] = {};
                state.windows[key].position = this.windows[key].position;
                state.windows[key].size = this.windows[key].size;
                state.windows[key].isMovable = this.windows[key].isMovable;
                state.windows[key].hasTitle = this.windows[key].hasTitle;
                state.windows[key].hasFrame = this.windows[key].hasFrame;
                state.windows[key].takesInput = this.windows[key].takesInput;
            }
        }

        return state;
    }

    setIfBigger(vec, nx, ny)
    {
        if( nx > vec.x ) vec.x = nx;
        if( ny > vec.y ) vec.y = ny;
    }

    setLastMousePosition(x, y)
    {
        this.mousePosition.setF32( x/this.scale, y/this.scale );
        this.lastMousePosition.setF32( x/this.scale, y/this.scale );

        // Loop through all windows to see if we're hovering over one.
        this.isHoveringWindow = false;
        for( let key in this.windows )
        {
            // Find which window is hovered and if it was clicked.
            if( this.windows[key].activeThisFrame && this.windows[key].takesInput &&
                this.windows[key].rect.contains( this.mousePosition ) )
            {
                if( this.mouseButtons[0] === false || this.ownsMouse === true )
                {
                    this.isHoveringWindow = true;
                }
            }
        }
    }

    newFrame(deltaTime)
    {
        this.frameCount++;
        this.currentTime += deltaTime;

        this.needsRefresh = false;
        
        this.mainMenuBarHeight = 0;

        // Backup our keyBuffer for use this frame and clear the array.
        this.unusedKeyBuffer = this.keyBuffer;
        this.keyBuffer.length = 0;

        this.windowHovered = null;
        this.isHoveringWindow = false;

        this.BGDrawList.length = 0;
        this.FGDrawList.length = 0;
        this.activeWindow = null;

        this.mousePosition.divideBy( this.scale );

        this.mouseChange = this.mousePosition.minus( this.lastMousePosition );
        this.mouseChangeUnscaled = this.mouseChange.times( this.scale );
        this.lastMousePosition.setF32( this.mousePosition.x, this.mousePosition.y );

        this.mouseDoubleClickedThisFrame[0] = false;
        if( this.mouseButtons[0] === true && this.oldMouseButtons[0] === false ) // Left button clicked.
        {
            if( this.currentTime - this.lastTimeMouseClicked[0] < this.doubleClickTime )
            {
                this.mouseDoubleClickedThisFrame[0] = true;
            }
        }

        let popupClicked = false;

        // Loop through all windows.
        for( let key in this.windows )
        {
            // Find which window is hovered and if it was clicked.
            if( this.windows[key].activeThisFrame && this.windows[key].takesInput &&
                this.windows[key].rect.contains( this.mousePosition ) )
            {
                this.windowHovered = this.windows[key];

                if( this.mouseButtons[0] === false || this.ownsMouse === true )
                {
                    this.isHoveringWindow = true;
                    this.ownsMouse = true;
                }

                if( this.mouseButtons[0] === true && this.oldMouseButtons[0] === false ) // Left button clicked.
                {
                    if( key.startsWith( "__Popup__" ) )
                    {
                        popupClicked = true;
                    }

                    this.windowBeingMoved = this.windows[key];
                }

                if( this.mouseButtons[1] === true && this.oldMouseButtons[1] === false ) // Middle button clicked.
                {
                    this.forceResize( this.windows[key] );
                    this.markStateDirty();
                }
            }

            // If this window didn't have a size, resize it to the biggest size it's been.
            this.activeWindow = this.windows[key];
            if( this.activeWindow.size.x === 0 )
            {
                this.forceResize( this.activeWindow );
            }

            // Reset their frame persistent values.
            this.windows[key].activeThisFrame = false;
            this.windows[key].cursor.set( this.windows[key].position );
            this.windows[key].previousLineEndPosition.setF32( 0, 0 );
        }

        if( this.mouseButtons[0] === true && this.oldMouseButtons[0] === false ) // Left button clicked.
        {
            if( popupClicked === false )
            {
                this.closeAllMenus();
            }
        }

        if( this.mouseButtons[0] === true && this.isHoveringWindow === false )
        {
            this.ownsMouse = false;
        }

        if( this.mouseButtons[0] === false ) // Not held.
        {
            if( this.windowMoved )
            {
                this.windowMoved = false;
                this.markStateDirty();
            }
            this.activeControl = null;
            this.windowBeingMoved = null;
            this.windowBeingResized = null;
        }

        if( this.buttonHeld !== null )
        {
            this.windowBeingMoved = null;
        }

        // Handle collapse or expand if window title double clicked.
        if( this.isHoveringControl === false && this.windowBeingMoved !== null && this.windowBeingMoved.hasTitle )
        {
            let titleH = this.fontSize.y + this.padding.y*2;
            if( this.mousePosition.y < this.windowBeingMoved.rect.y + titleH )
            {
                if( this.mouseDoubleClickedThisFrame[0] )
                {
                    this.windowBeingMoved.expanded = !this.windowBeingMoved.expanded;
                    this.windowBeingMoved = null;
                }
            }
        }

        // Handle dragging window around.
        if( this.isHoveringControl === false && this.windowBeingMoved && this.windowBeingMoved.isMovable )
        {
            if( this.mouseChange.x !== 0 || this.mouseChange.y !== 0 )
            {
                this.windowBeingMoved.position.add( this.mouseChange );
                this.windowBeingMoved.maxExtents.add( this.mouseChange );
                this.windowMoved = true;
                this.windowBeingMoved.cursor.set( this.windowBeingMoved.position );
            }
        }

        // Handle resizing window.
        if( this.isHoveringControl === false && this.windowBeingResized )
        {
            if( this.mouseChange.x !== 0 || this.mouseChange.y !== 0 )
            {
                let newSize = this.mousePosition.minus( this.windowBeingResized.position ).plus( this.windowResizeOffset );
                this.windowBeingResized.size.set( newSize );
                if( this.windowBeingResized.size.x < 16 )
                    this.windowBeingResized.size.x = 16;
                if( this.windowBeingResized.size.y < 16 )
                    this.windowBeingResized.size.y = 16;

                this.windowBeingResized.maxExtents.setF32( 0, 0 );
                this.windowMoved = true;
            }
        }

        //if( false )
        //{
        //    this.window( "TEST" );
        //    this.windows["TEST"].position.x = 300;
        //    this.windows["TEST"].position.y = 50;
        //    this.windows["TEST"].size.x = 250;
        //    this.windows["TEST"].size.y = 200;
        //    this.text( "Delta: " + this.mouseChange.x + " " + this.mouseChange.y );
        //    this.text( "Mouse Pos: " + this.mousePosition.x + " " + this.mousePosition.y );
        //    this.text( "Buttons: " + this.mouseButtons );
        //    if( this.windowHovered != null )
        //    {
        //        this.text( "Hovered: " + this.windowHovered.name );
        //    }
        //    if( this.windowBeingMoved )
        //    {
        //        this.text( "Rect XY: " + this.windowBeingMoved.rect.x + " " + this.windowBeingMoved.rect.y );
        //        this.text( "Rect WH: " + this.windowBeingMoved.rect.w + " " + this.windowBeingMoved.rect.h );
        //        this.text( "In Rect: " + this.windowBeingMoved.rect.contains( this.mousePosition ) );
        //    }
        //}

        // Update lastTimeMouseClicked to be able to detect double-clicks above.
        if( this.mouseButtons[0] === true && this.oldMouseButtons[0] === false ) // Left button clicked.
        {
            this.lastTimeMouseClicked[0] = this.currentTime;
        }
    }

    draw()
    {
        let gl = this.gl;

        gl.disable( gl.DEPTH_TEST );
        gl.enable( gl.BLEND );
        gl.blendFunc( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA );
        gl.enable( gl.SCISSOR_TEST );

        // Draw all items in draw list.
            //debugger;
        {
            for( let i=0; i<this.BGDrawList.length; i++ )
            {
                let item = this.BGDrawList[i];            
                this.drawItem( item );
                DrawListItem.returnToPool( item );
            }
            this.BGDrawList.length = 0;

            for( let i=0; i<this.FGDrawList.length; i++ )
            {
                let item = this.FGDrawList[i];            
                this.drawItem( item );
                DrawListItem.returnToPool( item );
            }
            this.FGDrawList.length = 0;
        }

        gl.disable( gl.SCISSOR_TEST );
        gl.enable( gl.DEPTH_TEST );

        // Backup old mouse state before DOM callbacks change current state.
        this.oldMouseButtons[0] = this.mouseButtons[0];
        this.oldMouseButtons[1] = this.mouseButtons[1];
        this.oldMouseButtons[2] = this.mouseButtons[2];

        this.isHoveringControl = false;
    }
    
    drawItem(item)
    {
        let gl = this.gl;

        let sizeofFloat32 = 4;
        let sizeofUint8 = 1;
        let sizeofUint16 = 2;
        
        // VertexFormat: XY UV RGBA. (4 floats + 4 uint8s or 5 floats or 20 bytes)
        let sizeofVertex = (4*sizeofFloat32 + 4*sizeofUint8);
        if( item.numVertComponents === 0 )
        {
            //debugger;
            return; 
        }

        {
            let vertCount = item.numVertComponents / 8;
            let spaceNeeded = vertCount * sizeofVertex;
            let verts = item.vertComponents;

            if( spaceNeeded > this.vertexAttributesBufferSize )
            {
                //console.log( "Increasing vertex ArrayBuffer size from " + this.vertexAttributesBufferSize + " to " + spaceNeeded );
                this.vertexAttributesBufferSize = spaceNeeded;
                this.vertexAttributes = new ArrayBuffer( spaceNeeded );
                this.vertexAttributesAsFloats = new Float32Array( this.vertexAttributes );
                this.vertexAttributesAsUint8s = new Uint8Array( this.vertexAttributes );
            }

            for( let i=0; i<vertCount; i++ )
            {
                this.vertexAttributesAsFloats[i*5 + 0] = verts[i*8 + 0];
                this.vertexAttributesAsFloats[i*5 + 1] = verts[i*8 + 1];
                this.vertexAttributesAsFloats[i*5 + 2] = verts[i*8 + 2];
                this.vertexAttributesAsFloats[i*5 + 3] = verts[i*8 + 3];
            }

            for( let i=0; i<vertCount; i++ )
            {
                this.vertexAttributesAsUint8s[i*sizeofVertex + 4*sizeofFloat32 + 0] = verts[i*8 + 4];
                this.vertexAttributesAsUint8s[i*sizeofVertex + 4*sizeofFloat32 + 1] = verts[i*8 + 5];
                this.vertexAttributesAsUint8s[i*sizeofVertex + 4*sizeofFloat32 + 2] = verts[i*8 + 6];
                this.vertexAttributesAsUint8s[i*sizeofVertex + 4*sizeofFloat32 + 3] = verts[i*8 + 7];
            }
        }

        let indexCount = 0;

        // Indices: Uint16.
        {
            indexCount = item.numIndices;
            let spaceNeeded = indexCount * sizeofUint16;
            let indices = item.indices;

            if( spaceNeeded > this.indicesBufferSize )
            {
                //console.log( "Increasing index ArrayBuffer size from " + this.indicesBufferSize + " to " + spaceNeeded );
                this.indicesBufferSize = spaceNeeded;
                this.indices16 = new ArrayBuffer( spaceNeeded );
                this.indicesAsUint16s = new Uint16Array( this.indices16 );
            }

            for( let i=0; i<indexCount; i++ )
            {
                this.indicesAsUint16s[i] = indices[i];
            }
        }

        gl.bindBuffer( gl.ARRAY_BUFFER, this.VBO );
        gl.bufferData( gl.ARRAY_BUFFER, this.vertexAttributes, gl.STREAM_DRAW );

        gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, this.IBO );
        gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, this.indices16, gl.STREAM_DRAW );

        // Set up VBO and attributes.
        gl.bindBuffer( gl.ARRAY_BUFFER, this.VBO );
        gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, this.IBO );

        let shader = this.shader;

        gl.enableVertexAttribArray( shader.a_Position );
        gl.vertexAttribPointer( shader.a_Position, 2, gl.FLOAT, false, sizeofVertex, 0 )

        if( shader.a_UV !== -1 )
        {
            gl.enableVertexAttribArray( shader.a_UV );
            gl.vertexAttribPointer( shader.a_UV, 2, gl.FLOAT, false, sizeofVertex, 8 )
        }

        if( shader.a_Color !== -1 )
        {
            gl.enableVertexAttribArray( shader.a_Color );
            gl.vertexAttribPointer( shader.a_Color, 4, gl.UNSIGNED_BYTE, true, sizeofVertex, 16 )
        }

        // Set up shader and uniforms.
        gl.useProgram( shader.program );

        // Ortho matrix with 0,0 at top-left.
        this.matProj.createOrthoInfiniteZ( 0, this.canvas.width / this.scale, this.canvas.height / this.scale, 0 );

        gl.uniformMatrix4fv( shader.u_MatProj, false, this.matProj.m )

        if( shader.u_TextureAlbedo !== null )
        {
            let textureUnit = 0;
            gl.activeTexture( gl.TEXTURE0 + textureUnit );
            gl.bindTexture( gl.TEXTURE_2D, this.font.texture.textureID );
            gl.uniform1i( shader.u_TextureAlbedo, textureUnit );
        }

        // Scissor.
        let lowerLeftY = this.canvas.height - (item.rect.y + item.rect.h) * this.scale;
        gl.scissor( item.rect.x * this.scale, lowerLeftY, item.rect.w * this.scale, item.rect.h * this.scale );
        
        // Draw.        
        gl.drawElements( item.primitiveType, indexCount, gl.UNSIGNED_SHORT, 0 );
        
        if( shader.a_UV !== -1 )
            gl.disableVertexAttribArray( shader.a_UV );
        if( shader.a_Color !== -1 )
            gl.disableVertexAttribArray( shader.a_Color );
    }

    sameLine()
    {
        this.activeWindow.cursor.set( this.activeWindow.previousLineEndPosition );
    }

    initWindow(name, onlySetIfNew, position, size, hasFrame, takesInput, hasTitle)
    {
        let existed = true;

        if( this.windows[name] === undefined )
        {
            this.windows[name] = new ImGuiWindow();
            this.windows[name].name = name;
            this.windows[name].maxExtents.setF32( 0, 0 );
            this.windows[name].hasTitle = true;
            this.windows[name].hasFrame = true;
            this.windows[name].takesInput = true;
            existed = false;
        }

        if( onlySetIfNew === false || existed === false )
        {
            if( position !== undefined )
            {
                this.windows[name].position.set( position );
                this.windows[name].cursor.set( position );
            }

            if( size !== undefined )
                this.windows[name].size.set( size );

            if( hasTitle !== undefined )
                this.windows[name].hasTitle = hasTitle;

            if( hasFrame !== undefined )
                this.windows[name].hasFrame = hasFrame;

            if( takesInput !== undefined )
                this.windows[name].takesInput = takesInput;
        }
    }

    pushColorChange(name, newColor)
    {
        this.colorChangeStack.push( [ name, new color(this.color[name]) ] );
        this.color[name].setFromColor( newColor );
    }

    popColorChange(numPops = 1)
    {
        for( let i=0; i<numPops; i++ )
        {
            let entry = this.colorChangeStack.pop();
            this.color[entry[0]].setFromColor( entry[1] );
        }
    }

    mainMenuBar()
    {
        let gl = this.gl;

        let name = "__mainMenuBar__";

        if( this.windows[name] === undefined )
        {
            let windowCount = Object.keys( this.windows ).length;

            this.windows[name] = new ImGuiWindow();
            this.windows[name].name = name;
            this.activeWindow = this.windows[name];
            
            this.activeWindow.position.setF32( 0, 0 );
            this.activeWindow.size.setF32( this.canvas.width / this.scale, this.fontSize.y + this.padding.y*4 - 1 );
            this.activeWindow.maxExtents.setF32( 0, 0 );
            this.activeWindow.cursor.setF32( this.activeWindow.position.x, this.activeWindow.position.y - 1 );
            this.activeWindow.hasTitle = true;
            this.activeWindow.hasFrame = true;
            this.activeWindow.takesInput = true;
            this.activeWindow.isMovable = false;
            this.activeWindow.saveState = false;
        }
        
        this.activeWindow = this.windows[name];
        this.activeWindow.activeThisFrame = true;
        this.activeWindow.cursor.setF32( this.activeWindow.position.x, this.activeWindow.position.y + 1 );

        // Draw the main menu bg.
        {
            let drawListItem = DrawListItem.getFromPool();
            
            let w = this.activeWindow.size.x;
            let h = this.activeWindow.size.y;
            this.mainMenuBarHeight = h;
            
            this.activeWindow.rect.set( 0, 0, w, h );

            this.addBoxToDrawListItem( drawListItem, 0,0,w,h, this.color["MenuBar"] );

            drawListItem.set( gl.TRIANGLES, this.activeWindow.rect );
            this.drawList.push( drawListItem );
        }
    }

    menu(name)
    {
        this.activeWindow = this.windows["__mainMenuBar__"];

        let menuItemPosition = this.activeWindow.cursor.x;

        this.pushColorChange( "ButtonNormal", this.color["MenuItemNormal"] );
        this.pushColorChange( "ButtonHovered", this.color["MenuItemHovered"] );
        this.pushColorChange( "ButtonPressed", this.color["MenuItemPressed"] );
        let pressed = this.button( name, true, true, false );
        this.popColorChange( 3 );

        this.sameLine();
        this.activeWindow.cursor.x += 10;

        let expanded = false;

        if( pressed )
        {
            this.closeAllMenusWithParent( this.windows["__Popup__" + name] );
        }

        if( pressed || this.activeMenus[name] !== undefined )
        {
            this.closeAllMenusWithParent( this.activeWindow );
            this.activeMenus[name] = {};
            this.activeMenus[name].parentWindow = this.activeWindow;
            
            // Pop up a menu window below this.
            let popupName = "__Popup__" + name;

            // Clear all old popups.
            this.FGDrawList.length = 0;
            this.drawList = this.FGDrawList;

            let x = menuItemPosition;
            let y = this.activeWindow.position.y + this.activeWindow.size.y;

            let size = vec2.getTemp( 0, 0 );
            if( this.windows[popupName] )
            {
                size.setF32( this.windows[popupName].size.x, this.windows[popupName].size.y );
            }
            else
            {
                this.needsRefresh = true;
            }

            this.initWindow( popupName, false, vec2.getTemp( x, y ), size, true, true, false );

            this.pushColorChange( "BG", this.color["MenuPopupBG"] );
            if( this.window( popupName ) )
            {
                this.activeWindow.cursor.y += this.popupPadding.y;
                expanded = true;
            }
            this.popColorChange();

            this.windows[popupName].isMovable = false;
            this.windows[popupName].saveState = false;
            this.forceResize( this.activeWindow );

            this.markStateDirty();
        }

        this.drawList = this.BGDrawList;
        return expanded;
    }

    submenu(name)
    {
        this.previousMenu = this.activeWindow;

        let menuItemPositionX = this.activeWindow.cursor.x + this.activeWindow.size.x;
        let menuItemPositionY = this.activeWindow.cursor.y;
        
        this.drawList = this.FGDrawList;

        // Resize the BG to fit the options... will have 1 frame lag.
        this.activeWindow.size.set( this.activeWindow.maxExtents.minus( this.activeWindow.position ) );
        this.activeWindow.size.x += this.padding.x + this.popupPadding.x;
        this.activeWindow.size.y += this.popupPadding.y;

        if( this.activeWindow.cursor.x === this.activeWindow.position.x )
        {
            this.activeWindow.cursor.x += this.popupPadding.x;
        }

        // Generate a label showing a small arrow at the end.
        // This will depend on the length of the longest button, based on the window size from previous frames.
        let buttonWidth = this.activeWindow.size.x - (this.padding.x*2 + this.popupPadding.x*2);
        let longestLabel = (buttonWidth - this.padding.x*2) / this.fontSize.x;
        let label = name;
        do
            label += " ";
        while( label.length < longestLabel - 1 )
        label += ">";

        // Show the button.
        this.pushColorChange( "ButtonNormal", this.color["MenuItemNormal"] );
        this.pushColorChange( "ButtonHovered", this.color["MenuItemHovered"] );
        this.pushColorChange( "ButtonPressed", this.color["MenuItemPressed"] );
        let pressed = this.button( label, true, true, true );
        this.popColorChange( 3 );

        let expanded = false;

        if( pressed || this.activeMenus[name] !== undefined )
        {
            this.closeAllMenusWithParent( this.activeWindow );
            this.activeMenus[name] = {};
            this.activeMenus[name].parentWindow = this.activeWindow;

            // Pop up a menu window below this.
            let popupName = "__Popup__" + name;
            
            let x = menuItemPositionX;
            let y = menuItemPositionY;
            
            let size = vec2.getTemp( 0, 0 );
            if( this.windows[popupName] )
            {
                size.setF32( this.windows[popupName].size.x, this.windows[popupName].size.y );
            }
            else
            {
                this.needsRefresh = true;
            }
            
            this.initWindow( popupName, false, vec2.getTemp( x, y ), size, true, true, false );
            
            this.pushColorChange( "BG", this.color["MenuPopupBG"] );
            if( this.window( popupName ) )
            {
                this.activeWindow.cursor.y += this.popupPadding.y;
                this.activeWindow.parentWindow = this.previousMenu;
                expanded = true;
            }
            this.popColorChange();
            
            this.windows[popupName].isMovable = false;
            this.windows[popupName].saveState = false;
            this.forceResize( this.activeWindow );
            
            this.markStateDirty();
        }

        this.drawList = this.BGDrawList;
        return expanded;
    }

    endSubmenu()
    {
        this.activeWindow = this.activeWindow.parentWindow;
    }

    menuItem(label)
    {
        this.drawList = this.FGDrawList;

        if( this.activeWindow.cursor.x === this.activeWindow.position.x )
        {
            this.activeWindow.cursor.x += this.popupPadding.x;
        }
        this.pushColorChange( "ButtonNormal", this.color["MenuItemNormal"] );
        this.pushColorChange( "ButtonHovered", this.color["MenuItemHovered"] );
        this.pushColorChange( "ButtonPressed", this.color["MenuItemPressed"] );
        let pressed = this.button( label, false, true, false );
        this.popColorChange( 3 );

        this.drawList = this.BGDrawList;

        // Resize the BG to fit the options... will have 1 frame lag.
        this.activeWindow.size.set( this.activeWindow.maxExtents.minus( this.activeWindow.position ) );
        this.activeWindow.size.x += this.padding.x + this.popupPadding.x;
        this.activeWindow.size.y += this.popupPadding.y;

        return pressed;
    }

    closeAllMenus()
    {
        this.activeMenus = [];
    }

    closeAllMenusWithParent( parentWindow )
    {
        for( let key in this.activeMenus )
        {
            if( this.activeMenus[key].parentWindow === parentWindow )
            {
                delete this.activeMenus[key];
            }
        }
    }

    // Return true is window is expanded.
    window(name)
    {
        let gl = this.gl;

        if( this.windows[name] === undefined )
        {
            let windowCount = Object.keys( this.windows ).length;

            this.windows[name] = new ImGuiWindow();
            this.windows[name].name = name;
            this.activeWindow = this.windows[name];
            
            this.activeWindow.position.setF32( 20 + 150*windowCount, 20 );
            this.activeWindow.cursor.set( this.activeWindow.position );
        }
        
        this.activeWindow = this.windows[name];
        this.activeWindow.activeThisFrame = true;

        // If the window is offscreen, force it back to 0,0.
        if( this.activeWindow.position.x + this.activeWindow.size.x < 0 || this.activeWindow.position.x >= this.canvas.width / this.scale ||
            this.activeWindow.position.y + this.activeWindow.size.y < 0 || this.activeWindow.position.y >= this.canvas.height / this.scale )
        {
            this.activeWindow.position.setF32( 0, 0 );
        }

        // If we're adding the window for the first time, add a title and BG.
        if( this.activeWindow.hasFrame === false )
        {
            let x = this.activeWindow.position.x;
            let y = this.activeWindow.position.y;
            
            let w = this.activeWindow.size.x;
            let h = this.activeWindow.size.y;

            this.activeWindow.rect.set( x, y, w, h );
        }
        else
        {
            if( this.activeWindow.cursor.y === this.activeWindow.position.y )
            {
                let drawListItem = DrawListItem.getFromPool();

                let x = this.activeWindow.position.x;
                let y = this.activeWindow.position.y;

                let w = this.activeWindow.size.x;

                let titleH = 0;

                // Draw the title box.
                if( this.activeWindow.hasTitle )
                {
                    titleH = this.fontSize.y + this.padding.y*2;
                    let h = titleH;
                    this.addBoxToDrawListItem( drawListItem, x,y,w,h, this.color["Title"] );
                    let t = 1/this.scale; // Border thickness, essentially 1 pixel regardless of UI scale.
                    this.addBoxToDrawListItem( drawListItem, x,    y, t,h, this.color["BGBorder"] ); // Border left.
                    this.addBoxToDrawListItem( drawListItem, x+w-t,y, t,h, this.color["BGBorder"] ); // Border right.
                    this.addBoxToDrawListItem( drawListItem, x,y,     w,t, this.color["BGBorder"] ); // Border top.
                    //this.addBoxToDrawListItem( drawListItem, x,y+h-t, w,t, this.color["BGBorder"] ); // Border bottom.
                }
                this.activeWindow.rect.set( x, y, w, titleH );

                if( this.activeWindow.expanded )
                {
                    // Draw the BG box.
                    y += titleH;
                    let h = this.activeWindow.size.y - titleH;
                    this.addBoxToDrawListItem( drawListItem, x,y,w,h, this.color["BG"] ); // BG filled.
                    let t = 1/this.scale; // Border thickness, essentially 1 pixel regardless of UI scale.
                    this.addBoxToDrawListItem( drawListItem, x,    y, t,h, this.color["BGBorder"] ); // Border left.
                    this.addBoxToDrawListItem( drawListItem, x+w-t,y, t,h, this.color["BGBorder"] ); // Border right.
                    if( this.activeWindow.hasTitle === false )
                        this.addBoxToDrawListItem( drawListItem, x,y,     w,t, this.color["BGBorder"] ); // Border top.
                    this.addBoxToDrawListItem( drawListItem, x,y+h-t, w,t, this.color["BGBorder"] ); // Border bottom.

                    // Define scissor rect, y is lower left.
                    let rx = this.activeWindow.position.x;
                    let ry = this.activeWindow.position.y;
                    let rw = this.activeWindow.size.x;
                    let rh = this.activeWindow.size.y;
                    this.activeWindow.rect.set( rx, ry, rw, rh );
                }

                // Adjust rect for main menu bar, if needed.
                if( this.activeWindow.rect.y < this.mainMenuBarHeight )
                {
                    this.activeWindow.rect.h -= this.mainMenuBarHeight - this.activeWindow.rect.y;
                    this.activeWindow.rect.y = this.mainMenuBarHeight;
                }

                drawListItem.set( gl.TRIANGLES, this.activeWindow.rect );
                this.drawList.push( drawListItem );

                if( this.activeWindow.hasTitle )
                {
                    if( this.checkbox( "", this.activeWindow.expanded ) )
                    {
                        this.activeWindow.expanded = !this.activeWindow.expanded;
                    }

                    this.sameLine();
                    this.text( name );
                }
            }

            if( this.activeWindow.hasTitle )
            {
                // Button at bottom right to resize window.
                if( this.activeWindow.expanded )
                {
                    let x = this.activeWindow.cursor.x;
                    let y = this.activeWindow.cursor.y;
                    let rect = this.activeWindow.rect;
                    this.activeWindow.cursor.x = rect.x + rect.w - (this.padding.x + this.fontSize.x + this.padding.x)
                    this.activeWindow.cursor.y = rect.y + rect.h - (this.padding.y + this.fontSize.y + this.padding.y)
                    let oldMaxX = this.activeWindow.maxExtents.x;
                    let oldMaxY = this.activeWindow.maxExtents.y;
                    if( this.button( this.buttonString, true, false, false ) )
                    {
                        this.windowBeingResized = this.activeWindow;
                        this.windowResizeOffset.setF32( rect.x + rect.w - this.mousePosition.x, rect.y + rect.h - this.mousePosition.y );
                    }
                    this.activeWindow.maxExtents.setF32( oldMaxX, oldMaxY );
                    this.activeWindow.cursor.x = x;
                    this.activeWindow.cursor.y = y;
                }
            }
        }

        return this.activeWindow.expanded;
    }

    forceResize(window)
    {
        window.size.set( window.maxExtents.minus( window.position ) );
        window.size.x += this.padding.x;
        window.size.y += this.padding.y + this.fontSize.y + this.padding.y;
    }

    addBoxToDrawListItem(drawListItem, x, y, w, h, color)
    {
        let numVerts = drawListItem.numVertComponents/8;
        drawListItem.pushVert( x+0,y+h,   0,0,   color.r,color.g,color.b,color.a );
        drawListItem.pushVert( x+0,y+0,   0,0,   color.r,color.g,color.b,color.a );
        drawListItem.pushVert( x+w,y+0,   0,0,   color.r,color.g,color.b,color.a );
        drawListItem.pushVert( x+w,y+h,   0,0,   color.r,color.g,color.b,color.a );
        drawListItem.pushIndex( numVerts+0 );
        drawListItem.pushIndex( numVerts+1 );
        drawListItem.pushIndex( numVerts+2 );
        drawListItem.pushIndex( numVerts+0 );
        drawListItem.pushIndex( numVerts+2 );
        drawListItem.pushIndex( numVerts+3 );
    }

    addStringToDrawList(str, x, y, rect = undefined)
    {
        let gl = this.gl;

        let w = this.fontSize.x;
        let h = this.fontSize.y;

        let drawListItem = DrawListItem.getFromPool();

        let count = 0;
        for( let i=0; i<str.length; i++ )
        {
            let c = str.charCodeAt(i);
            if( c === 32 ) // Handle spaces.
            {
                x += w;
                continue;
            }
            if( c === 97+6 || c === 97+9 || c === 97+15 || c === 97+16 || c === 97+24 ) // g/j/p/q/y
                y += 2;
            // Greek symbols.
                 if( c === 916 ) c = 130; // Δ
            else if( c === 952 ) c = 143; // θ
            else if( c === 969 ) c = 144; // ω
            else if( c > 150 )
                console.log( "character not supported: " + c );
            c -= this.font.firstChar;
            let cx = Math.trunc( c % this.font.gridSize.x );
            let cy = Math.trunc( c / this.font.gridSize.x );

            let numVerts = drawListItem.numVertComponents/8;
            drawListItem.pushVert( x+0,y+h, this.font.stepU*(cx+0),               this.font.stepV*(cy+this.font.charH), 255,255,255,255 );
            drawListItem.pushVert( x+0,y+0, this.font.stepU*(cx+0),               this.font.stepV*(cy+0),               255,255,255,255 );
            drawListItem.pushVert( x+w,y+0, this.font.stepU*(cx+this.font.charW), this.font.stepV*(cy+0),               255,255,255,255 );
            drawListItem.pushVert( x+w,y+h, this.font.stepU*(cx+this.font.charW), this.font.stepV*(cy+this.font.charH), 255,255,255,255 );
            drawListItem.pushIndex( numVerts+0 );
            drawListItem.pushIndex( numVerts+1 );
            drawListItem.pushIndex( numVerts+2 );
            drawListItem.pushIndex( numVerts+0 );
            drawListItem.pushIndex( numVerts+2 );
            drawListItem.pushIndex( numVerts+3 );

            x += w;
            c += this.font.firstChar;
            if( c === 97+6 || c === 97+9 || c === 97+15 || c === 97+16 || c === 97+24 ) // g/j/p/q/y
                y -= 2;
            count++;
        }

        if( rect === undefined )
            rect = this.largeRect;

        drawListItem.set( gl.TRIANGLES, rect );
        this.drawList.push( drawListItem );

        return vec2.getTemp( x, y );
    }

    text(str)
    {
        // if( this.activeWindow.expanded == false )
        //     return;

        this.activeWindow.cursor.x += this.padding.x;
        this.activeWindow.cursor.y += this.padding.y;
        let x = this.activeWindow.cursor.x;
        let y = this.activeWindow.cursor.y;

        let h = this.fontSize.y;

        let pos = this.addStringToDrawList( str, x, y, this.activeWindow.rect );

        this.activeWindow.previousLineEndPosition.setF32( pos.x-this.padding.x, pos.y-this.padding.y );
        this.setIfBigger( this.activeWindow.maxExtents, pos.x, pos.y + this.fontSize.y + this.padding.y );

        this.activeWindow.cursor.setF32( pos.x, pos.y+h );
        this.activeWindow.cursor.y += this.padding.y;

        this.activeWindow.cursor.x = this.activeWindow.position.x;
    }

    button(label, returnTrueIfButtonIsHeldDown = false, allowPressIfMouseAlreadyHeld = false, returnTrueIfButtonIsHovered = false)
    {
        // if( this.activeWindow.expanded == false )
        //     return;

        let gl = this.gl;

        let w = this.padding.x + label.length * this.fontSize.x + this.padding.x;
        let buttonTopPadding = 1;
        let h = buttonTopPadding + this.fontSize.y + this.padding.y;

        let drawListItem = DrawListItem.getFromPool();

        let x = this.activeWindow.cursor.x + this.padding.x;
        let y = this.activeWindow.cursor.y + buttonTopPadding;

        // Check if we're hovering over this button inside this window.
        let isHovering = false;
        let color = this.color["ButtonNormal"];
        let rect = ImGuiRect.getFromPool( x, y, w, h );
        if( rect.contains( this.mousePosition ) )
        {
            if( this.activeWindow === this.windowHovered )
            {
                isHovering = true;
                color = this.color["ButtonHovered"];

                // Store if the button was clicked this frame.
                if( (this.mouseButtons[0] === true && this.oldMouseButtons[0] === false) ||
                    (allowPressIfMouseAlreadyHeld && this.mouseButtons[0] === true) )
                {
                    //if( this.buttonHeld != label && this.oldMouseButtons[0] == true )
                    //    debugger;

                    this.buttonHeld = label;
                }

                if( this.buttonHeld === label )
                {
                    color = this.color["ButtonPressed"];
                }
            }
        }
        ImGuiRect.returnToPool( rect );

        this.addBoxToDrawListItem( drawListItem, x,y,w,h, color );

        drawListItem.set( gl.TRIANGLES, this.activeWindow.rect );
        this.drawList.push( drawListItem );

        this.activeWindow.cursor.x += this.padding.x;
        this.text( label );
        this.activeWindow.previousLineEndPosition.setF32( x + w, y - buttonTopPadding );
        this.setIfBigger( this.activeWindow.maxExtents, x + w, y + this.fontSize.y + this.padding.y );

        // Check if button was triggered.
        let triggered = false;

        // If this button is held down.
        if( this.buttonHeld === label )
        {
            this.isHoveringControl = true;

            if( isHovering )
            {
                // If holding the button is considered "triggered".
                if( returnTrueIfButtonIsHeldDown && this.buttonHeld === label )
                    triggered = true;

                // If mouse released while button is held.
                if( this.mouseButtons[0] === false && this.oldMouseButtons[0] === true )
                    triggered = true;
            }

            // If mouse button is up, stop considering this button as held down.
            if( this.mouseButtons[0] === false )
                this.buttonHeld = null;
        }

        if( isHovering )
        {
            // If hovering over the button is considered "triggered".
            if( returnTrueIfButtonIsHovered )
            {
                this.isHoveringControl = true;
                triggered = true;
            }
        }

        if( triggered )
        {
            this.windowBeingMoved = null;
            //this.windowBeingResized = null;
            this.needsRefresh = true;
            return true;
        }

        return false;
    }

    checkbox(label, isChecked)
    {
        // if( this.activeWindow.expanded == false )
        //     return;

        let gl = this.gl;

        this.text( label );
        this.sameLine();
        this.activeWindow.cursor.x += this.padding.x;

        let w = this.padding.x + this.fontSize.x + this.padding.x;
        let buttonTopPadding = 1;
        let h = buttonTopPadding + this.fontSize.y + this.padding.y;

        let drawListItem = DrawListItem.getFromPool();

        let x = this.activeWindow.cursor.x + this.padding.x;
        let y = this.activeWindow.cursor.y + buttonTopPadding;

        let isHovering = false;
        let color = this.color["ButtonNormal"];
        let rect = ImGuiRect.getFromPool( x, y, w, h );
        if( rect.contains( this.mousePosition ) ) // is hovering.
        {
            if( this.activeWindow === this.windowHovered )
            {
                isHovering = true;
                color = this.color["ButtonHovered"];

                if( this.mouseButtons[0] === true ) // is pressing.
                {
                    color = this.color["ButtonPressed"];
                }
            }
        }
        ImGuiRect.returnToPool( rect );

        this.addBoxToDrawListItem( drawListItem, x,y,w-1,h-1, color );

        if( isChecked )
        {
            color = this.color["Checkbox"];
            this.addBoxToDrawListItem( drawListItem, x+2,y+2,w-5,h-5, color );
        }

        drawListItem.set( gl.TRIANGLES, this.activeWindow.rect );
        this.drawList.push( drawListItem );

        this.activeWindow.cursor.x += this.padding.x;
        this.activeWindow.previousLineEndPosition.setF32( x + w, y - buttonTopPadding );
        this.setIfBigger( this.activeWindow.maxExtents, x + w, y + this.fontSize.y + this.padding.y );
        this.activeWindow.cursor.x = this.activeWindow.position.x;
        this.activeWindow.cursor.y += this.padding.y + this.fontSize.y + this.padding.y;
        
        // Check if was pressed this frame.
        if( isHovering &&
            ( ( this.mouseButtons[0] === true && this.oldMouseButtons[0] === false ) ) )
        {
            this.isHoveringControl = true;
            this.windowBeingMoved = null;
            //this.windowBeingResized = null;
            this.needsRefresh = true;
            return true;
        }

        return false;
    }

    dragNumber(label, value, increment, decimalPlaces, minLimit, maxLimit)
    {
        // if( this.activeWindow.expanded == false )
        //     return;

        let gl = this.gl;

        let startValue = value;

        // Label and a bit of padding to it's right.
        this.text( label );
        this.sameLine();
        this.activeWindow.cursor.x += this.padding.x;
        let valueAsString = value.toFixed( decimalPlaces );

        // Vars.
        let drawListItem = DrawListItem.getFromPool();

        let buttonTopPadding = 1;
        let offsetx = this.activeWindow.cursor.x - this.activeWindow.position.x;
        let boxWidth = (this.activeWindow.size.x - offsetx) - this.padding.x*2;
        if( boxWidth < this.minDragBoxWidth )
            boxWidth = this.minDragBoxWidth;

        let x = this.activeWindow.cursor.x + this.padding.x;
        let y = this.activeWindow.cursor.y + buttonTopPadding;
        let w = boxWidth;
        let h = buttonTopPadding + this.fontSize.y + this.padding.y;

        let isHovering = false;

        // Draw background and determine if mouse if hovering over it.
        {
            let color = this.color["ButtonNormal"];
            let rect = ImGuiRect.getFromPool( x, y, w, h );
            if( rect.contains( this.mousePosition ) ) // is hovering.
            {
                if( this.activeWindow === this.windowHovered )
                {
                    isHovering = true;
                }
            }
            ImGuiRect.returnToPool( rect );

            if( this.controlInEditMode === label )
            {
                color = this.color["TextBoxSelected"];
            }
            else if( isHovering )
            {
                color = this.color["ButtonHovered"];

                if( this.mouseButtons[0] === true ) // is pressing.
                {
                    color = this.color["ButtonPressed"];
                }
            }

            this.addBoxToDrawListItem( drawListItem, x,y,w,h, color );
        }

        // Calculate some values for the text string.
        if( this.controlInEditMode === label )
        {
            valueAsString = this.activeControlTextBuffer.join( "" );
        }
        let textWidth = valueAsString.length*this.fontSize.x;
        let textStartPoint = boxWidth/2 - textWidth/2;

        // Draw a highlight around the selected text by drawing a second bg block.
        if( this.controlInEditMode === label && this.activeControlTextBufferSelected === true )
        {
            let h = buttonTopPadding + this.fontSize.y + this.padding.y;

            let color = this.color["TextSelected"];

            this.addBoxToDrawListItem( drawListItem, x + textStartPoint,y,textWidth,h, color );
        }

        // Add BG verts to draw list.
        drawListItem.set( gl.TRIANGLES, this.activeWindow.rect );
        this.drawList.push( drawListItem );

        // Draw value as text.
        {
            this.activeWindow.cursor.x += textStartPoint;

            // Add a blinking cursor if we're editing this piece of text.
            if( this.controlInEditMode === label )
            {
                if( this.currentTime % 1.0 < 0.5 )
                    valueAsString += String.fromCharCode( 31 );
            }

            // Draw text without affecting maxExtents.
            let oldMaxX = this.activeWindow.maxExtents.x;
            let oldMaxY = this.activeWindow.maxExtents.y;
            this.text( valueAsString );
            this.activeWindow.maxExtents.setF32( oldMaxX, oldMaxY );

            // Place cursor at end of text.
            this.sameLine();
        }

        // Adjust extents and cursor position.
        let minWidth = 40;
        if( minWidth < valueAsString.length*this.fontSize.x )
        {
            minWidth = valueAsString.length*this.fontSize.x + this.padding.x * 2;
        }

        this.activeWindow.cursor.x += this.padding.x;
        this.activeWindow.previousLineEndPosition.setF32( x + w, y - buttonTopPadding );
        this.setIfBigger( this.activeWindow.maxExtents, x + minWidth, y + this.fontSize.y + this.padding.y );
        this.activeWindow.cursor.x = this.activeWindow.position.x;
        this.activeWindow.cursor.y += this.padding.y + this.fontSize.y + this.padding.y;

        // Check if the control was pressed this frame.
        if( isHovering &&
            ( ( this.mouseButtons[0] === true && this.oldMouseButtons[0] === false ) ) )
        {
            this.activeControl = label;
            this.isHoveringControl = true;
            this.windowBeingMoved = null;
            //this.windowBeingResized = null;
        }

        let doneWithEditMode = false;

        // If we're not hovering the control and mouse is clicked, exit edit mode.
        if( isHovering === false )
        {
            if( this.mouseButtons[0] === true && this.oldMouseButtons[0] === false ) // Left button clicked.
                doneWithEditMode = true;
        }

        // If hovering and double-clicked, switch to edit mode.
        if( isHovering && this.mouseButtons[0] === true && this.oldMouseButtons[0] === false ) // Left button clicked.
        {
            if( this.controlInEditMode !== label && this.mouseDoubleClickedThisFrame[0] )
            {
                this.controlInEditMode = label;
                this.activeControlTextBuffer = valueAsString.split( "" );
                this.activeControlTextBufferSelected = true;
            }
        }

        // If this control is in edit mode, empty the unusedKeyBuffer into it.
        if( this.controlInEditMode === label )
        {
            for( let i=0; i<this.unusedKeyBuffer.length; i++ )
            {
                if( this.unusedKeyBuffer[i] === "Backspace" )
                {
                    if( this.activeControlTextBufferSelected )
                    {
                        this.activeControlTextBuffer.length = 0;
                        this.activeControlTextBufferSelected = false;
                    }

                    if( this.activeControlTextBuffer.length > 0 )
                    {
                        this.activeControlTextBuffer.length = this.activeControlTextBuffer.length-1;
                    }
                }
                else if( this.unusedKeyBuffer[i] === "Enter" )
                {
                    doneWithEditMode = true;
                }
                else if( this.unusedKeyBuffer[i].length === 1 )
                {
                    if( this.activeControlTextBufferSelected )
                    {
                        this.activeControlTextBuffer.length = 0;
                        this.activeControlTextBufferSelected = false;
                    }

                    this.activeControlTextBuffer.push( this.unusedKeyBuffer[i] );
                }
                else
                {
                    this.activeControlTextBufferSelected = false;
                }
            }

            if( this.activeControlTextBuffer.length > 0 )
            {
                let string = this.activeControlTextBuffer.join( "" );
                let newValue = Number( string );
                if( isNaN( newValue ) === false )
                    value = newValue;
            }

            if( doneWithEditMode )
            {
                this.controlInEditMode = null;
                this.activeControlTextBuffer.length = 0;
            }
        }

        // If mouse held.
        if( this.activeControl === label &&
            this.mouseButtons[0] === true && this.oldMouseButtons[0] === true )
        {
            value += this.mouseChangeUnscaled.x * increment;
        }

        if( minLimit !== undefined ) { if( value < minLimit ) value = minLimit; }
        if( maxLimit !== undefined ) { if( value > maxLimit ) value = maxLimit; }

        let changed = false;
        if( value !== startValue )
        {
            changed = true;
            this.needsRefresh = true;
        }

        return [value, changed];
    }
}

class ImGuiWindow
{
    constructor()
    {
        this.name = null;
        this.position = new vec2( 0, 0 );
        this.size = new vec2( 0, 0 );
    
        this.activeThisFrame = false;
        this.cursor = new vec2(0);
        this.previousLineEndPosition = new vec2(0);
        this.rect = new ImGuiRect(0,0,0,0);

        this.expanded = true;
        this.maxExtents = new vec2(0); // Stores the lower right screen x/y of the window (not just the biggest size).

        this.saveState = true;

        this.hasTitle = true;
        this.hasFrame = true;
        this.isMovable = true;
        this.takesInput = true;
    }
}

class DrawListItem
{
    static pool = new Pool( DrawListItem, 100, true );
    static getFromPool(primitiveType, rect)
    {
        let obj = DrawListItem.pool.getFromPool();
        obj.clear();
        if( primitiveType !== undefined )
            obj.set( primitiveType, rect ); 
        return obj;
    }
    static returnToPool(obj) { return DrawListItem.pool.returnToPool( obj ); }

    constructor(primitiveType, rect)
    {
        if( primitiveType !== undefined )
            this.set( primitiveType, rect );

        // Set verts and indices sizes to the worst case imgui currently needs.
        this.vertComponents = new Array( 56 * 8 );
        this.indices = new Array( 80 );
        this.numVertComponents = 0;
        this.numIndices = 0;
    }

    set(primitiveType, rect)
    {
        this.primitiveType = primitiveType;
        this.rect = rect;
    }

    clear()
    {
        this.numVertComponents = 0;
        this.numIndices = 0;
    }

    pushVert(x,y,u,v,r,g,b,a)
    {
        let spaceNeeded = (this.numVertComponents + 8) - this.vertComponents.length;
        //if( spaceNeeded > 0 )
        //{
        //    console.log( "Increasing drawListItem's verts by " + spaceNeeded );
        //}
        while( spaceNeeded > 0 )
        {
            this.vertComponents.push(0);
            spaceNeeded--;
        }

        this.vertComponents[this.numVertComponents+0] = x;
        this.vertComponents[this.numVertComponents+1] = y;
        this.vertComponents[this.numVertComponents+2] = u;
        this.vertComponents[this.numVertComponents+3] = v;
        this.vertComponents[this.numVertComponents+4] = r;
        this.vertComponents[this.numVertComponents+5] = g;
        this.vertComponents[this.numVertComponents+6] = b;
        this.vertComponents[this.numVertComponents+7] = a;

        this.numVertComponents += 8;
    }

    pushIndex(index)
    {
        if( this.numIndices === this.indices.length )
        {
            //console.log( "Increasing drawListItem's indices by " + 1 );
            this.indices.push( index );
        }
        else
        {
            this.indices[this.numIndices] = index;
        }
        this.numIndices++;
    }
}

class ImGuiRect
{
    static pool = new Pool( ImGuiRect, 1000, true );
    static getFromPool(x,y,w,h)
    {
        let obj = ImGuiRect.pool.getFromPool();
        obj.set(x,y,w,h); 
        return obj;
    }
    static returnToPool(obj) { return ImGuiRect.pool.returnToPool( obj ); }

    constructor(x,y,w,h)
    {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
    }

    set(x,y,w,h)
    {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
    }

    contains(pos)
    {
        if( pos.x > this.x && pos.x < this.x + this.w &&
            pos.y > this.y && pos.y < this.y + this.h )
        {
            return true;
        }
        
        return false;
    }
}

class FontDef
{
    constructor(texture, firstChar, charSize, gridSize, padding, textureRes)
    {
        this.texture = texture;
        this.firstChar = firstChar;
        this.gridSize = gridSize;
        this.stepU = (charSize.x+padding.x) / textureRes.x;
        this.stepV = (charSize.y+padding.y) / textureRes.y;
        this.charW = charSize.x / (charSize.x+padding.x);
        this.charH = charSize.y / (charSize.y+padding.y);
    }
}
