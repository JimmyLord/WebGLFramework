namespace fw
{
    type stackColorEntry =
    [
        name: string, color: color
    ]

    class activeMenuEntry
    {
        parentWindow: ImGuiWindow | null = null;
    }

    export class ImGui
    {
        gl: WebGL2RenderingContext;
        canvas: HTMLCanvasElement;

        // Temp vars to avoid GC.
        matProj: mat4;
        buttonString: string;
        largeRect: ImGuiRect;

        vertexAttributesBufferSize: number;
        vertexAttributes: ArrayBuffer | null = null;
        vertexAttributesAsFloats: Float32Array | null = null;
        vertexAttributesAsUint8s: Uint8Array | null = null;
        indicesBufferSize: number;
        indices16: ArrayBuffer | null = null;;
        indicesAsUint16s: Uint16Array | null = null;;

        // Persistent values.
        BGDrawList: DrawListItem[];
        FGDrawList: DrawListItem[];
        drawList: DrawListItem[];
        windows: { [key: string]: ImGuiWindow }
        nextWindowZOrder: number; // z-order isn't fully implemented, it's only used to give the main menu focus over the windows.
        frameCount: number;
        currentTime: number;
        ownsMouse: boolean;
        lastTimeMouseClicked: number[];
        mouseDoubleClickedThisFrame: boolean[];
        mouseChange: vec2;
        mouseChangeUnscaled: vec2;
        lastMousePosition: vec2;
        unusedKeyBuffer: string[];
        mainMenuBarHeight: number; // How tall is the main menu bar (0 if no bar is active).
        activeWindow: ImGuiWindow | null = null;;
        previousMenu: ImGuiWindow | null = null;
        activeControl: string | null = null;;
        buttonHeld: string | null = null;;
        controlInEditMode: string | null = null;;
        activeControlTextBuffer: string[];
        activeControlTextBufferSelected: boolean; // TODO: Allow only parts of text to be selected and overwritten. and display something.
        windowHovered: ImGuiWindow | null = null;
        windowBeingMoved: ImGuiWindow | null = null;
        windowBeingResized: ImGuiWindow | null = null;
        windowResizeOffset: vec2;
        windowMoved: boolean;
        oldMouseButtons: boolean[];
        stateIsDirty: boolean;
        font: FontDef | null = null;
        fontSize: vec2;
        activeMenus: { [key: string]: activeMenuEntry } | null = null;

        // Colors.
        colors: { [key: string]: color };
        colorChangeStack: stackColorEntry[]; // Will hold a pair of ["name", "previous color"] for each overwrite.

        // Persistent values within single frame.

        // Settings.
        scale: number;
        padding: vec2;
        popupPadding: vec2;
        doubleClickTime: number;
        minDragBoxWidth: number;

        // Inputs.
        mousePosition: vec2;
        mouseButtons: boolean[];
        keyBuffer: string[];

        // Outputs.
        isHoveringWindow: boolean;
        isHoveringControl: boolean;
        needsRefresh: boolean;

        // Resources.
        VBO: WebGLBuffer | null = null;
        IBO: WebGLBuffer | null = null;

        shader: Shader | null = null;

        constructor(gl: WebGL2RenderingContext, canvas: HTMLCanvasElement)
        {
            this.gl = gl;
            this.canvas = canvas;

            // Temp vars to avoid GC.
            this.matProj = new mat4();
            this.buttonString = " ";
            this.largeRect = new ImGuiRect( 0, 0, 10000, 10000 );

            this.vertexAttributesBufferSize = 0;
            this.vertexAttributes = null;
            this.vertexAttributesAsFloats = null;
            this.vertexAttributesAsUint8s = null;
            this.indicesBufferSize = 0;
            this.indices16 = null;
            this.indicesAsUint16s = null;

            // Persistent values.
            this.BGDrawList = [];
            this.FGDrawList = [];
            this.drawList = this.BGDrawList;
            this.windows = {};
            this.nextWindowZOrder = 0; // z-order isn't fully implemented, it's only used to give the main menu focus over the windows.
            this.frameCount = 0;
            this.currentTime = 0;
            this.ownsMouse = false;
            this.lastTimeMouseClicked = [ 0, 0, 0 ];
            this.mouseDoubleClickedThisFrame = [ false, false, false ];
            this.mouseChange = new vec2(0);
            this.mouseChangeUnscaled = new vec2(0);
            this.lastMousePosition = new vec2(0);
            this.unusedKeyBuffer = [];
            this.mainMenuBarHeight = 0; // How tall is the main menu bar (0 if no bar is active).
            this.activeWindow = null;
            this.previousMenu = null;
            this.activeControl = null;
            this.buttonHeld = null;
            this.controlInEditMode = null;
            this.activeControlTextBuffer = [];
            this.activeControlTextBufferSelected = false; // TODO: Allow only parts of text to be selected and overwritten. and display something.
            this.windowHovered = null;
            this.windowBeingMoved = null;
            this.windowBeingResized = null;
            this.windowResizeOffset = new vec2(0);
            this.windowMoved = false;
            this.oldMouseButtons = [ false, false, false ];
            this.stateIsDirty = false;
            this.font = null;
            this.fontSize = new vec2(0);
            this.activeMenus = {};

            // Colors.
            this.colors = {};
            this.colors["Title"] =           new color(   0,   0,  50, 255 );
            this.colors["BG"] =              new color(   0,   0,  25, 200 );
            this.colors["BGBorder"] =        new color( 100, 100, 100, 255 );
            this.colors["ButtonNormal"] =    new color(  50,  50, 200, 255 );
            this.colors["ButtonHovered"] =   new color(  80,  80, 230, 255 );
            this.colors["ButtonPressed"] =   new color( 120, 120, 255, 255 );
            this.colors["MenuBar"] =         new color(  30, 100, 200, 255 );
            this.colors["MenuPopupBG"] =     new color(   0,   0,   0, 255 );
            this.colors["MenuItemNormal"] =  new color(   0,   0,   0,   0 );
            this.colors["MenuItemHovered"] = new color(  80,  80,  80, 255 );
            this.colors["MenuItemPressed"] = new color( 120, 120, 120, 255 );
            this.colors["Checkbox"] =        new color( 196, 196, 196, 255 );
            this.colors["TextBoxSelected"] = new color( 100,   0,   0, 255 );
            this.colors["TextSelected"] =    new color( 200,  60,   0, 255 );
            this.colorChangeStack = []; // Will hold a pair of ["name", "previous color"] for each overwrite.

            // Persistent values within single frame.

            // Settings.
            this.scale = 2;
            this.padding = new vec2(2);
            this.popupPadding = new vec2(4,5);
            this.doubleClickTime = 0.3;
            this.minDragBoxWidth = 60;

            // Inputs.
            this.mousePosition = new vec2(0);
            this.mouseButtons = [ false, false, false ];
            this.keyBuffer = [];
            
            // Outputs.
            this.isHoveringWindow = false;
            this.isHoveringControl = false;
            this.needsRefresh = false;

            // Resources.
            this.VBO = gl.createBuffer();
            this.IBO = gl.createBuffer();

            let imguiVertShaderSource = `
                attribute vec4 a_Position;
                attribute vec2 a_UV;
                attribute vec4 a_Color;

                uniform mat4 u_MatProj;

                varying vec2 v_UV;
                varying vec4 v_Color;

                void main()
                {
                    gl_Position = u_MatProj * a_Position;
                    v_UV = a_UV;
                    v_Color = a_Color;
                }
            `;

            let imguiFragShaderSource = `
                precision mediump float;

                uniform sampler2D u_TextureAlbedo;

                varying vec2 v_UV;
                varying vec4 v_Color;
                
                void main()
                {
                    gl_FragColor = texture2D( u_TextureAlbedo, v_UV ).rrrr * 255.0 * v_Color;
                }
            `;

            this.shader = new Shader( gl, imguiVertShaderSource, imguiFragShaderSource );

            this.fontSize.setF32( 7, 8 );
            this.generateFontTexture();
        }

        generateFontTexture()
        {
            let pixels = new Uint8Array( [
                // Each char is 7x8 + 2 on right and 1 on bottom for padding.
                // Sheet is 13x8 chars ATM, so 117x72 pixels.
                // Dummy full-white block for window backgrounds and other things. 
                // 1 solid BG + 4 unused + 31(blinking cursor) + 32(space) + 33-38: !"#$%&      +    11 chars padding to reach 128 bytes wide.
                1,1,1,1,1,1,1, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,1,0,1,0, 0,0, 0,0,1,0,1,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,1,1,0,0,0,0, 0,0, 0,0,1,1,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                1,1,1,1,1,1,1, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,1,0,1,0, 0,0, 0,0,1,0,1,0,0, 0,0, 0,1,1,1,1,1,1, 0,0, 0,1,1,0,0,0,1, 0,0, 0,1,0,0,1,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                1,1,1,1,1,1,1, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1, 0,0, 0,1,0,0,1,0,0, 0,0, 0,0,0,0,0,1,0, 0,0, 0,1,0,0,1,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                1,1,1,1,1,1,1, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,1,0,1,0,0, 0,0, 0,1,0,0,1,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,1,0,1,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                1,1,1,1,1,1,1, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1, 0,0, 0,1,1,1,1,1,1, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                1,1,1,1,1,1,1, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,1,0,1,0,0, 0,0, 0,0,0,0,1,0,1, 0,0, 0,0,1,0,0,0,0, 0,0, 0,0,1,0,1,0,1, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                1,1,1,1,1,1,1, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,1,0,1,0,0, 0,0, 0,1,1,1,1,1,1, 0,0, 0,1,0,0,0,1,1, 0,0, 0,1,0,0,0,1,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                1,1,1,1,1,1,1, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,1,0,1,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,0,0,1,1, 0,0, 0,0,1,1,1,0,1, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                // 39-51: '()*+,-./00,0,0,0,0,0,0123    0,0,0,0,0,0,0       0,0,0,0,0,0,0       0,0,0,0,0,0,0
                0,0,0,0,1,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,1,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,1,0, 0,0, 0,0,1,1,1,1,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,1,1,1,1,1,1, 0,0, 0,1,1,1,1,1,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,0,1,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,1,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,0,1,1,0,0, 0,0, 0,0,0,0,0,0,1, 0,0, 0,0,0,0,0,0,1, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,0,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,0,0,0,1, 0,0, 0,0,0,0,0,0,1, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,0,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,1,0,1,0,1,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,0,0,1,0,0, 0,0, 0,1,1,1,1,1,1, 0,0, 0,0,1,1,1,1,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,0,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,1,1,1,0,0, 0,0, 0,1,1,1,1,1,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,1,1,1,1,1,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,0,0,1,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,0,0,0,0,0,1, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,0,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,1,0,1,0,1,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,1,1,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,0,0,1,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,0,0,0,0,0,1, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,0,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,1,1,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,1,1,0,0,0, 0,0, 0,0,1,0,0,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,0,0,1,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,0,0,0,0,0,1, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,0,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,1,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,1,1,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,1,1,0,0,0, 0,0, 0,0,1,0,0,0,0, 0,0, 0,0,1,1,1,1,0, 0,0, 0,0,0,1,1,1,0, 0,0, 0,1,1,1,1,1,1, 0,0, 0,1,1,1,1,1,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                // 52-64: 456789:;<=>?@
                0,1,0,0,0,0,1, 0,0, 0,1,1,1,1,1,1, 0,0, 0,1,1,1,1,1,1, 0,0, 0,1,1,1,1,1,1, 0,0, 0,1,1,1,1,1,1, 0,0, 0,1,1,1,1,1,1, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,1,1,0,0, 0,0, 0,0,1,1,1,1,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,0,0,0,0,0,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,0,1,1,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,1, 0,0, 0,0,0,0,0,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,0,1,0,0,1,0, 0,0, 0,1,0,0,0,0,1, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,0,0,0,0,1,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,0,1,1,0,0, 0,0, 0,0,0,1,1,0,0, 0,0, 0,0,0,0,1,1,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,1,1,0,0,0, 0,0, 0,0,0,0,0,0,1, 0,0, 0,1,0,1,1,0,1, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,1,1,1,1,1,1, 0,0, 0,1,1,1,1,1,1, 0,0, 0,1,1,1,1,1,1, 0,0, 0,0,0,0,0,1,0, 0,0, 0,1,1,1,1,1,1, 0,0, 0,1,1,1,1,1,1, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,1,1,0,0, 0,0, 0,0,1,1,0,0,0, 0,0, 0,1,1,1,1,1,0, 0,0, 0,0,0,0,1,1,0, 0,0, 0,0,0,0,0,0,1, 0,0, 0,1,0,1,1,0,1, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,0,0,0,1, 0,0, 0,0,0,0,0,0,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,0,0,1,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,0,0,0,0,1, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,1, 0,0, 0,0,0,0,1,1,0, 0,0, 0,1,0,1,0,0,1, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,0,0,0,1, 0,0, 0,0,0,0,0,0,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,0,0,1,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,0,0,0,0,1, 0,0, 0,0,0,1,1,0,0, 0,0, 0,0,0,1,1,0,0, 0,0, 0,0,1,1,0,0,0, 0,0, 0,1,1,1,1,1,0, 0,0, 0,0,0,0,1,1,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,1,0,0,1,1,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,0,0,0,1, 0,0, 0,0,0,0,0,0,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,0,1,0,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,0,0,0,0,1, 0,0, 0,0,0,1,1,0,0, 0,0, 0,0,0,1,1,0,0, 0,0, 0,0,0,0,1,1,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,1,1,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,0,0,0,1, 0,0, 0,1,1,1,1,1,1, 0,0, 0,1,1,1,1,1,1, 0,0, 0,0,0,1,0,0,0, 0,0, 0,1,1,1,1,1,1, 0,0, 0,0,0,0,0,0,1, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,1,1,0,0,0, 0,0, 0,0,0,0,0,0,1, 0,0, 0,0,0,0,0,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,1,1,1,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                // 65-77: Upper case A-M
                0,0,0,1,1,0,0, 0,0, 0,1,1,1,1,1,0, 0,0, 0,1,1,1,1,1,0, 0,0, 0,1,1,1,1,1,0, 0,0, 0,1,1,1,1,1,1, 0,0, 0,1,1,1,1,1,0, 0,0, 0,1,1,1,1,1,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,1,1,1,1,1, 0,0, 0,0,0,1,1,1,1, 0,0, 0,1,0,0,0,1,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,1,0,0,1,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,0,0,1,0, 0,0, 0,1,0,0,0,1,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,1,0,0,1,1, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,1,0,0,1,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,0,0,1,0, 0,0, 0,1,0,0,1,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,1,1,0,1, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,1,0,0,0,0,1, 0,0, 0,1,1,1,1,1,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,0,0,1,0, 0,0, 0,1,0,1,0,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,1,1,1,1,1,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,1,1,1,1,1, 0,0, 0,1,1,1,1,0,0, 0,0, 0,1,0,0,1,1,1, 0,0, 0,1,1,1,1,1,1, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,0,0,1,0, 0,0, 0,1,1,0,0,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,0,0,1,0, 0,0, 0,1,0,1,0,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,1,0,0,1,0, 0,0, 0,1,0,0,1,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,1,0,0,0,0,1, 0,0, 0,1,1,1,1,1,0, 0,0, 0,1,1,1,1,1,0, 0,0, 0,1,1,1,1,1,0, 0,0, 0,1,1,1,1,1,1, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,1,1,1,1,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,1,1,1,1,1, 0,0, 0,0,0,1,1,0,0, 0,0, 0,1,0,0,0,1,0, 0,0, 0,1,1,1,1,1,0, 0,0, 0,1,0,0,0,0,1, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                // 78-90: Upper case N-Z
                0,1,0,0,0,0,1, 0,0, 0,0,1,1,1,1,0, 0,0, 0,1,1,1,1,1,0, 0,0, 0,0,1,1,1,1,0, 0,0, 0,1,1,1,1,1,0, 0,0, 0,0,1,1,1,1,1, 0,0, 0,0,1,1,1,1,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,1,0,0,0,1, 0,0, 0,1,1,1,1,1,1, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,1,1,0,0,0,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,1,0,0,1,0, 0,0, 0,0,1,0,0,0,1, 0,0, 0,0,0,0,0,0,1, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,1,0,1,0,0,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,1,0,0,1,0, 0,0, 0,0,0,1,0,1,0, 0,0, 0,0,0,0,0,1,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,1,0,0,1,0,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,1,1,1,1,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,1,0,0,1,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,0,1,1,0,0, 0,0, 0,0,0,1,0,1,0, 0,0, 0,0,0,0,1,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,1,0,0,0,1,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,1,1,1,1,0, 0,0, 0,0,1,1,1,1,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,1,0,0,1,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,0,1,1,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,1,0,1, 0,0, 0,1,0,0,1,0,0, 0,0, 0,0,0,0,0,0,1, 0,0, 0,0,0,0,1,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,1,0,0,1,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,1,0,0,1,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,1,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,0,1,1, 0,0, 0,1,0,0,0,1,0, 0,0, 0,0,0,0,0,0,1, 0,0, 0,0,0,0,1,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,1,1,1,1,0, 0,0, 0,1,0,1,1,0,1, 0,0, 0,0,1,0,0,1,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,1,0,0,0,0,1, 0,0, 0,0,1,1,1,1,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,0,1,1,1,1,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,1,1,1,1,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,1,1,1,1,0, 0,0, 0,0,0,1,1,0,0, 0,0, 0,1,1,0,0,1,1, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,0,0,1,0,0, 0,0, 0,1,1,1,1,1,1, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                // 91-103: [\]^_`abcdefg
                0,0,0,1,1,1,0, 0,0, 0,0,1,0,0,0,0, 0,0, 0,0,1,1,1,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,1,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,1,0,0,0, 0,0, 0,0,1,0,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,1,0,1,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,1,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,1,1,0, 0,0, 0,0,1,1,1,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,1,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,1,0,0,0,1, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,1,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,1,0,0,0,1,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,1,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,1,1,1,0,0, 0,0, 0,1,1,1,1,0,0, 0,0, 0,0,1,1,1,0,0, 0,0, 0,0,1,1,1,1,0, 0,0, 0,0,1,1,1,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,1,0,0,0,1,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,1,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,1,0, 0,0, 0,1,0,0,0,1,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,0,1,0, 0,0, 0,1,0,0,0,1,0, 0,0, 0,0,1,1,1,0,0, 0,0, 0,1,0,0,0,1,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,1,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,1,1,1,0,0, 0,0, 0,1,0,0,0,1,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,0,1,0, 0,0, 0,1,1,1,1,1,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,1,1,1,1,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,1,0,0,0, 0,0, 0,0,0,0,0,1,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,1,0,0,0,1,0, 0,0, 0,1,0,0,0,1,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,0,0,0,1,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,0,0,0,1,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,1,1,1,0, 0,0, 0,0,0,0,0,1,0, 0,0, 0,0,1,1,1,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,1,1,1,1,1,1, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,1,1,1,0,1, 0,0, 0,1,1,1,1,0,0, 0,0, 0,0,1,1,1,0,0, 0,0, 0,0,1,1,1,1,0, 0,0, 0,0,1,1,1,1,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,1,1,1,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                // 104-116: hijklmnopqrst
                0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,1,1,1,0,0, 0,0, 0,0,1,1,1,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,1,0,0,0,0,0, 0,0, 0,0,1,0,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,1,0,0,0,1,0, 0,0, 0,1,0,0,0,1,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,1,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,1,0,0,1,0, 0,0, 0,0,1,1,1,0,0, 0,0, 0,0,1,1,1,0,0, 0,0, 0,1,0,0,0,1,0, 0,0, 0,1,0,0,0,1,0, 0,0, 0,1,0,1,1,0,0, 0,0, 0,0,1,1,1,0,0, 0,0, 0,0,1,1,1,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,1,1,1,1,0,0, 0,0, 0,0,1,0,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,1,0,1,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,1,0,1,1,0,1, 0,0, 0,1,0,0,0,1,0, 0,0, 0,1,0,0,0,1,0, 0,0, 0,1,0,0,0,1,0, 0,0, 0,1,0,0,0,1,0, 0,0, 0,1,1,0,0,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,1,0,0,0,1,0, 0,0, 0,0,1,0,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,1,1,0,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,1,0, 0,0, 0,1,0,0,0,1,0, 0,0, 0,1,1,1,1,0,0, 0,0, 0,0,1,1,1,1,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,0,1,1,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,1,0,0,0,1,0, 0,0, 0,0,1,0,0,0,0, 0,0, 0,1,0,0,1,0,0, 0,0, 0,1,0,1,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,1,0, 0,0, 0,1,0,0,0,1,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,0,0,0,0,1,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,1,0,0,0,1,0, 0,0, 0,0,1,0,0,0,0, 0,0, 0,0,1,1,0,0,0, 0,0, 0,1,0,0,1,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,1,0, 0,0, 0,0,1,1,1,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,0,0,0,0,1,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,1,1,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                // 117-129: uvwxyz{|}~ + 3 unused
                0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,1,0,0,0,1,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,1,0,0,0,1,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,1,0,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,0,0,1,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,1,0,0,0,1,0, 0,0, 0,1,0,0,0,1,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,1,0,0,0,1,0, 0,0, 0,0,1,0,1,0,0, 0,0, 0,1,1,1,1,1,0, 0,0, 0,0,1,0,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,0,0,1,0, 0,0, 0,1,1,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,1,0,0,0,1,0, 0,0, 0,1,0,0,0,1,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,1,0,1,0,0, 0,0, 0,0,1,0,1,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,0,0,0,1, 0,0, 1,0,0,1,0,0,1, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,1,0,0,0,1,0, 0,0, 0,0,1,0,1,0,0, 0,0, 0,1,0,0,0,0,1, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,1,0,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,0,0,1,0, 0,0, 0,0,0,0,1,1,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,1,0,0,0,1,0, 0,0, 0,0,1,0,1,0,0, 0,0, 0,1,0,1,1,0,1, 0,0, 0,0,1,0,1,0,0, 0,0, 0,0,1,0,0,0,0, 0,0, 0,0,1,0,0,0,0, 0,0, 0,0,1,0,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,0,0,1,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,1,1,1,0,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,1,0,0,1,0, 0,0, 0,1,0,0,0,1,0, 0,0, 0,1,0,0,0,0,0, 0,0, 0,1,1,1,1,1,0, 0,0, 0,0,0,1,0,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,0,1,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                // 130-142: upper-case greek symbols: Δ
                0,0,0,1,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,1,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,1,0,1,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,1,0,1,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,1,0,0,0,1,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,1,0,0,0,1,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                1,0,0,0,0,0,1, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                1,1,1,1,1,1,1, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                // 143-155: lower-case greek symbols: θω
                0,0,0,1,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,1,0,1,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,1,0,0,0,1,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,1,0,0,0,1,0, 0,0, 0,1,0,0,0,1,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,1,1,1,1,1,0, 0,0, 1,0,0,0,0,0,1, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,1,0,0,0,1,0, 0,0, 1,0,0,1,0,0,1, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,1,0,1,0,0, 0,0, 1,0,0,1,0,0,1, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,1,0,0,0, 0,0, 0,1,1,0,1,1,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                // Padding for power of two texture.
                //pixels 90-99
                0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                //pixels 100-109
                0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                //pixels 110-119
                0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                //pixels 120-127
                0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
                0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 0,0,0,0,0,0,0, 0,0, 1,1,1,1,1,1,1,1,1,1,0,
            ] );

            let texture = new Texture( this.gl );
            let textureRes = new vec2( 128, 128 );
            texture.createFromUInt8Array( pixels, textureRes.x, textureRes.y );

            let firstChar = 33 - 7; // -7 for window BG block + 4 unused spots + 1 blinking cursor (31) + space (32)
            let charSize = new vec2( 7, 8 );
            let gridSize = new vec2( 13, 8 );
            let padding = new vec2( 2, 1 );

            this.font = new FontDef( texture, firstChar, charSize, gridSize, padding, textureRes );
        }

        loadState(imguiState: string)
        {
            //return;
            let state = null;
            try { state = JSON.parse( imguiState ); }
            catch( e ) { return; }

            this.scale = state.scale;
            this.doubleClickTime = state.doubleClickTime;
            this.minDragBoxWidth = state.minDragBoxWidth;

            for( let key in state.windows )
            {
                this.windows[key] = new ImGuiWindow();
                this.windows[key].name = key;
                let window = this.windows[key];

                window.position.setF32( state.windows[key].position["x"], state.windows[key].position["y"] );
                window.size.setF32( state.windows[key].size["x"], state.windows[key].size["y"] );
                window.cursor.set( window.position );
                window.isMovable = state.windows[key].isMovable;
                window.hasTitle = state.windows[key].hasTitle;
                window.hasFrame = state.windows[key].hasFrame;
                window.takesInput = state.windows[key].takesInput;
                
                // If the window is offscreen, force it back to 0,0.
                if( window.position.x + window.size.x < 0 || window.position.x >= this.canvas.width / this.scale ||
                    window.position.y + window.size.y < 0 || window.position.y >= this.canvas.height / this.scale )
                {
                    window.position.setF32( 0, 0 );
                }
            }
        }

        markStateDirty()
        {
            this.stateIsDirty = true;
        }

        saveState(storage: Storage, name: string)
        {
            if( this.stateIsDirty )
            {
                //console.log( "Saving imgui state." );

                storage[name] = JSON.stringify( this );
                this.stateIsDirty = false;
            }
        }

        toJSON()
        {
            type stateType = {
                scale: number,
                doubleClickTime: number,
                minDragBoxWidth: number,
                windows: {[key: string]: ImGuiWindow}
            }

            let state: stateType = {
                scale: this.scale,
                doubleClickTime: this.doubleClickTime,
                minDragBoxWidth: this.minDragBoxWidth,
                windows: {}
            }
            
            for( let key in this.windows )
            {
                if( this.windows[key].saveState === true )
                {
                    state.windows[key] = new ImGuiWindow;
                    state.windows[key].position = this.windows[key].position;
                    state.windows[key].size = this.windows[key].size;
                    state.windows[key].isMovable = this.windows[key].isMovable;
                    state.windows[key].hasTitle = this.windows[key].hasTitle;
                    state.windows[key].hasFrame = this.windows[key].hasFrame;
                    state.windows[key].takesInput = this.windows[key].takesInput;
                }
            }

            return state;
        }

        setIfBigger(vec: vec2, nx: number, ny: number)
        {
            if( nx > vec.x ) vec.x = nx;
            if( ny > vec.y ) vec.y = ny;
        }

        setLastMousePosition(x: number, y: number)
        {
            this.mousePosition.setF32( x/this.scale, y/this.scale );
            this.lastMousePosition.setF32( x/this.scale, y/this.scale );

            // Loop through all windows to see if we're hovering over one.
            this.isHoveringWindow = false;
            for( let key in this.windows )
            {
                // Find which window is hovered and if it was clicked.
                if( this.windows[key].activeThisFrame && this.windows[key].takesInput &&
                    this.windows[key].rect.contains( this.mousePosition ) )
                {
                    if( this.mouseButtons[0] === false || this.ownsMouse === true )
                    {
                        this.isHoveringWindow = true;
                    }
                }
            }
        }

        newFrame(deltaTime: number)
        {
            this.frameCount++;
            this.currentTime += deltaTime;

            this.needsRefresh = false;
            
            this.mainMenuBarHeight = 0;

            // Backup our keyBuffer for use this frame and clear the array.
            this.unusedKeyBuffer.length = 0;
            for( let i=0; i<this.keyBuffer.length; i++ )
                this.unusedKeyBuffer.push( this.keyBuffer[i] );
            this.keyBuffer.length = 0;

            this.nextWindowZOrder = 0;
            this.windowHovered = null;
            this.isHoveringWindow = false;

            this.BGDrawList.length = 0;
            this.FGDrawList.length = 0;
            this.activeWindow = null;

            this.mousePosition.divideBy( this.scale );

            this.mouseChange.set( this.mousePosition.minus( this.lastMousePosition ) );
            this.mouseChangeUnscaled.set( this.mouseChange.times( this.scale ) );
            this.lastMousePosition.setF32( this.mousePosition.x, this.mousePosition.y );

            this.mouseDoubleClickedThisFrame[0] = false;
            if( this.mouseButtons[0] === true && this.oldMouseButtons[0] === false ) // Left button clicked.
            {
                if( this.currentTime - this.lastTimeMouseClicked[0] < this.doubleClickTime )
                {
                    this.mouseDoubleClickedThisFrame[0] = true;
                }
            }

            let popupClicked = false;

            // Find which window is hovered and if it was clicked. Pick the one with the highest z-order.
            let highestZOrder = -1;
            for( let key in this.windows )
            {
                if( this.windows[key].activeThisFrame && this.windows[key].takesInput &&
                    this.windows[key].rect.contains( this.mousePosition ) )
                {
                    if( this.windows[key].zOrder > highestZOrder )
                    {
                        this.windowHovered = this.windows[key];
                        highestZOrder = this.windows[key].zOrder;
                    }
                }
            }

            // Loop through all windows.
            for( let key in this.windows )
            {
                // If this window didn't have a size, resize it to the biggest size it's been.
                this.activeWindow = this.windows[key];
                if( this.activeWindow.size.x === 0 )
                {
                    this.forceResize( this.activeWindow );
                }

                // Reset their frame persistent values.
                this.windows[key].activeThisFrame = false;
                this.windows[key].cursor.set( this.windows[key].position );
                this.windows[key].previousLineEndPosition.setF32( 0, 0 );
            }

            if( this.windowHovered !== null )
            {
                if( this.mouseButtons[0] === false || this.ownsMouse === true )
                {
                    this.isHoveringWindow = true;
                    this.ownsMouse = true;
                }

                if( this.mouseButtons[0] === true && this.oldMouseButtons[0] === false ) // Left button clicked.
                {
                    if( this.windowHovered && this.windowHovered.name.startsWith( "__Popup__" ) )
                    {
                        popupClicked = true;
                    }

                    this.windowBeingMoved = this.windowHovered;
                }

                if( this.mouseButtons[1] === true && this.oldMouseButtons[1] === false ) // Middle button clicked.
                {
                    this.forceResize( this.windowHovered );
                    this.markStateDirty();
                }
            }

            if( this.mouseButtons[0] === true && this.oldMouseButtons[0] === false ) // Left button clicked.
            {
                if( popupClicked === false )
                {
                    this.closeAllMenus();
                }
            }

            if( this.mouseButtons[0] === true && this.isHoveringWindow === false )
            {
                this.ownsMouse = false;
            }

            if( this.mouseButtons[0] === false ) // Not held.
            {
                if( this.windowMoved )
                {
                    this.windowMoved = false;
                    this.markStateDirty();
                }
                this.activeControl = null;
                this.windowBeingMoved = null;
                this.windowBeingResized = null;
            }

            if( this.buttonHeld !== null )
            {
                this.windowBeingMoved = null;
            }

            // Handle collapse or expand if window title double clicked.
            if( this.isHoveringControl === false && this.windowBeingMoved !== null && this.windowBeingMoved.hasTitle )
            {
                let titleH = this.fontSize.y + this.padding.y*2;
                if( this.mousePosition.y < this.windowBeingMoved.rect.y + titleH )
                {
                    if( this.mouseDoubleClickedThisFrame[0] )
                    {
                        this.windowBeingMoved.expanded = !this.windowBeingMoved.expanded;
                        this.windowBeingMoved = null;
                    }
                }
            }

            // Handle dragging window around.
            if( this.isHoveringControl === false && this.windowBeingMoved && this.windowBeingMoved.isMovable )
            {
                if( this.mouseChange.x !== 0 || this.mouseChange.y !== 0 )
                {
                    this.windowBeingMoved.position.add( this.mouseChange );
                    this.windowBeingMoved.maxExtents.add( this.mouseChange );
                    this.windowMoved = true;
                    this.windowBeingMoved.cursor.set( this.windowBeingMoved.position );
                }
            }

            // Handle resizing window.
            if( this.isHoveringControl === false && this.windowBeingResized )
            {
                if( this.mouseChange.x !== 0 || this.mouseChange.y !== 0 )
                {
                    let newSize = this.mousePosition.minus( this.windowBeingResized.position ).plus( this.windowResizeOffset );
                    this.windowBeingResized.size.set( newSize );
                    if( this.windowBeingResized.size.x < 16 )
                        this.windowBeingResized.size.x = 16;
                    if( this.windowBeingResized.size.y < 16 )
                        this.windowBeingResized.size.y = 16;

                    this.windowBeingResized.maxExtents.setF32( 0, 0 );
                    this.windowMoved = true;
                }
            }

            //if( false )
            //{
            //    this.window( "TEST" );
            //    this.windows["TEST"].position.x = 300;
            //    this.windows["TEST"].position.y = 50;
            //    this.windows["TEST"].size.x = 250;
            //    this.windows["TEST"].size.y = 200;
            //    this.text( "Delta: " + this.mouseChange.x + " " + this.mouseChange.y );
            //    this.text( "Mouse Pos: " + this.mousePosition.x + " " + this.mousePosition.y );
            //    this.text( "Buttons: " + this.mouseButtons );
            //    if( this.windowHovered != null )
            //    {
            //        this.text( "Hovered: " + this.windowHovered.name );
            //    }
            //    if( this.windowBeingMoved )
            //    {
            //        this.text( "Rect XY: " + this.windowBeingMoved.rect.x + " " + this.windowBeingMoved.rect.y );
            //        this.text( "Rect WH: " + this.windowBeingMoved.rect.w + " " + this.windowBeingMoved.rect.h );
            //        this.text( "In Rect: " + this.windowBeingMoved.rect.contains( this.mousePosition ) );
            //    }
            //}

            // Update lastTimeMouseClicked to be able to detect double-clicks above.
            if( this.mouseButtons[0] === true && this.oldMouseButtons[0] === false ) // Left button clicked.
            {
                this.lastTimeMouseClicked[0] = this.currentTime;
            }
        }

        draw()
        {
            let gl = this.gl;

            gl.disable( gl.DEPTH_TEST );
            gl.enable( gl.BLEND );
            gl.blendFunc( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA );
            gl.enable( gl.SCISSOR_TEST );

            // Draw all items in draw list.
                //debugger;
            {
                for( let i=0; i<this.BGDrawList.length; i++ )
                {
                    let item = this.BGDrawList[i];            
                    this.drawItem( item );
                    DrawListItem.returnToPool( item );
                }
                this.BGDrawList.length = 0;

                for( let i=0; i<this.FGDrawList.length; i++ )
                {
                    let item = this.FGDrawList[i];            
                    this.drawItem( item );
                    DrawListItem.returnToPool( item );
                }
                this.FGDrawList.length = 0;
            }

            gl.disable( gl.SCISSOR_TEST );
            gl.enable( gl.DEPTH_TEST );

            // Backup old mouse state before DOM callbacks change current state.
            this.oldMouseButtons[0] = this.mouseButtons[0];
            this.oldMouseButtons[1] = this.mouseButtons[1];
            this.oldMouseButtons[2] = this.mouseButtons[2];

            this.isHoveringControl = false;
        }
        
        drawItem(item: DrawListItem)
        {
            let gl = this.gl;

            let sizeofFloat32 = 4;
            let sizeofUint8 = 1;
            let sizeofUint16 = 2;
            
            // VertexFormat: XY UV RGBA. (4 floats + 4 uint8s or 5 floats or 20 bytes)
            let sizeofVertex = (4*sizeofFloat32 + 4*sizeofUint8);
            if( item.numVertComponents === 0 )
            {
                //debugger;
                return; 
            }

            {
                let vertCount = item.numVertComponents / 8;
                let spaceNeeded = vertCount * sizeofVertex;
                let verts = item.vertComponents;

                if( spaceNeeded > this.vertexAttributesBufferSize )
                {
                    //console.log( "Increasing vertex ArrayBuffer size from " + this.vertexAttributesBufferSize + " to " + spaceNeeded );
                    this.vertexAttributesBufferSize = spaceNeeded;
                    this.vertexAttributes = new ArrayBuffer( spaceNeeded );
                    this.vertexAttributesAsFloats = new Float32Array( this.vertexAttributes );
                    this.vertexAttributesAsUint8s = new Uint8Array( this.vertexAttributes );
                }

                if( this.vertexAttributesAsFloats == null ) return;
                if( this.vertexAttributesAsUint8s == null ) return;

                for( let i=0; i<vertCount; i++ )
                {
                    this.vertexAttributesAsFloats[i*5 + 0] = verts[i*8 + 0];
                    this.vertexAttributesAsFloats[i*5 + 1] = verts[i*8 + 1];
                    this.vertexAttributesAsFloats[i*5 + 2] = verts[i*8 + 2];
                    this.vertexAttributesAsFloats[i*5 + 3] = verts[i*8 + 3];
                }

                for( let i=0; i<vertCount; i++ )
                {
                    this.vertexAttributesAsUint8s[i*sizeofVertex + 4*sizeofFloat32 + 0] = verts[i*8 + 4];
                    this.vertexAttributesAsUint8s[i*sizeofVertex + 4*sizeofFloat32 + 1] = verts[i*8 + 5];
                    this.vertexAttributesAsUint8s[i*sizeofVertex + 4*sizeofFloat32 + 2] = verts[i*8 + 6];
                    this.vertexAttributesAsUint8s[i*sizeofVertex + 4*sizeofFloat32 + 3] = verts[i*8 + 7];
                }
            }

            let indexCount = 0;

            // Indices: Uint16.
            {
                indexCount = item.numIndices;
                let spaceNeeded = indexCount * sizeofUint16;
                let indices = item.indices;

                if( spaceNeeded > this.indicesBufferSize )
                {
                    //console.log( "Increasing index ArrayBuffer size from " + this.indicesBufferSize + " to " + spaceNeeded );
                    this.indicesBufferSize = spaceNeeded;
                    this.indices16 = new ArrayBuffer( spaceNeeded );
                    this.indicesAsUint16s = new Uint16Array( this.indices16 );
                }

                if( this.indicesAsUint16s == null ) return;

                for( let i=0; i<indexCount; i++ )
                {
                    this.indicesAsUint16s[i] = indices[i];
                }
            }

            gl.bindBuffer( gl.ARRAY_BUFFER, this.VBO );
            gl.bufferData( gl.ARRAY_BUFFER, this.vertexAttributes, gl.STREAM_DRAW );

            gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, this.IBO );
            gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, this.indices16, gl.STREAM_DRAW );

            // Set up VBO and attributes.
            gl.bindBuffer( gl.ARRAY_BUFFER, this.VBO );
            gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, this.IBO );

            let shader = this.shader;
            if( shader == null ) return;

            gl.enableVertexAttribArray( shader.a_Position );
            gl.vertexAttribPointer( shader.a_Position, 2, gl.FLOAT, false, sizeofVertex, 0 )

            if( shader.a_UV !== -1 )
            {
                gl.enableVertexAttribArray( shader.a_UV );
                gl.vertexAttribPointer( shader.a_UV, 2, gl.FLOAT, false, sizeofVertex, 8 )
            }

            if( shader.a_Color !== -1 )
            {
                gl.enableVertexAttribArray( shader.a_Color );
                gl.vertexAttribPointer( shader.a_Color, 4, gl.UNSIGNED_BYTE, true, sizeofVertex, 16 )
            }

            // Set up shader and uniforms.
            gl.useProgram( shader.program );

            // Ortho matrix with 0,0 at top-left.
            this.matProj.createOrthoInfiniteZ( 0, this.canvas.width / this.scale, this.canvas.height / this.scale, 0 );

            gl.uniformMatrix4fv( shader.u_MatProj, false, this.matProj.m )

            if( shader.u_TextureAlbedo !== null && this.font !== null )
            {
                let textureUnit = 0;
                gl.activeTexture( gl.TEXTURE0 + textureUnit );
                gl.bindTexture( gl.TEXTURE_2D, this.font.texture.textureID );
                gl.uniform1i( shader.u_TextureAlbedo, textureUnit );
            }

            // Scissor.
            let lowerLeftY = this.canvas.height - (item.rect.y + item.rect.h) * this.scale;
            gl.scissor( item.rect.x * this.scale, lowerLeftY, item.rect.w * this.scale, item.rect.h * this.scale );
            
            // Draw.        
            gl.drawElements( item.primitiveType, indexCount, gl.UNSIGNED_SHORT, 0 );
            
            if( shader.a_UV !== -1 )
                gl.disableVertexAttribArray( shader.a_UV );
            if( shader.a_Color !== -1 )
                gl.disableVertexAttribArray( shader.a_Color );
        }

        sameLine()
        {
            if( this.activeWindow )
            {
                this.activeWindow.cursor.set( this.activeWindow.previousLineEndPosition );
            }
        }

        initWindow(name: string, onlySetIfNew: boolean, position: vec2, size: vec2, hasFrame: boolean, takesInput: boolean, hasTitle: boolean)
        {
            let existed = true;

            if( this.windows[name] === undefined )
            {
                this.windows[name] = new ImGuiWindow();
                this.windows[name].name = name;
                this.windows[name].maxExtents.setF32( 0, 0 );
                this.windows[name].hasTitle = true;
                this.windows[name].hasFrame = true;
                this.windows[name].takesInput = true;
                existed = false;
            }

            if( onlySetIfNew === false || existed === false )
            {
                if( position !== undefined )
                {
                    this.windows[name].position.set( position );
                    this.windows[name].cursor.set( position );
                }

                if( size !== undefined )
                    this.windows[name].size.set( size );

                if( hasTitle !== undefined )
                    this.windows[name].hasTitle = hasTitle;

                if( hasFrame !== undefined )
                    this.windows[name].hasFrame = hasFrame;

                if( takesInput !== undefined )
                    this.windows[name].takesInput = takesInput;
            }
        }

        pushColorChange(name: string, newColor: color)
        {
            this.colorChangeStack.push( [ name, new color(this.colors[name]) ] );
            this.colors[name].setFromColor( newColor );
        }

        popColorChange(numPops = 1)
        {
            for( let i=0; i<numPops; i++ )
            {
                let entry = this.colorChangeStack.pop();
                if( entry !== undefined)
                {
                    this.colors[entry[0]].setFromColor( entry[1] );
                }
            }
        }

        mainMenuBar()
        {
            let gl = this.gl;

            let name = "__mainMenuBar__";

            if( this.windows[name] === undefined )
            {
                let windowCount = Object.keys( this.windows ).length;

                this.windows[name] = new ImGuiWindow();
                this.windows[name].name = name;
                this.activeWindow = this.windows[name];
                
                this.activeWindow.position.setF32( 0, 0 );
                this.activeWindow.size.setF32( this.canvas.width / this.scale, this.fontSize.y + this.padding.y*4 - 1 );
                this.activeWindow.maxExtents.setF32( 0, 0 );
                this.activeWindow.cursor.setF32( this.activeWindow.position.x, this.activeWindow.position.y - 1 );
                this.activeWindow.hasTitle = true;
                this.activeWindow.hasFrame = true;
                this.activeWindow.takesInput = true;
                this.activeWindow.isMovable = false;
                this.activeWindow.saveState = false;
            }
            
            this.activeWindow = this.windows[name];
            this.activeWindow.activeThisFrame = true;
            this.activeWindow.cursor.setF32( this.activeWindow.position.x, this.activeWindow.position.y + 1 );

            // Partial implementation of z-ordering, main menu is always in foreground.
            this.activeWindow.zOrder = 9999999;

            // Draw the main menu bg.
            {
                let drawListItem = DrawListItem.getFromPool();
                
                let w = this.activeWindow.size.x;
                let h = this.activeWindow.size.y;
                this.mainMenuBarHeight = h;
                
                this.activeWindow.rect.set( 0, 0, w, h );

                this.addBoxToDrawListItem( drawListItem, 0,0,w,h, this.colors["MenuBar"] );

                drawListItem.set( gl.TRIANGLES, this.activeWindow.rect );
                this.drawList.push( drawListItem );
            }
        }

        menu(name: string)
        {
            this.activeWindow = this.windows["__mainMenuBar__"];

            let menuItemPosition = this.activeWindow.cursor.x;

            this.pushColorChange( "ButtonNormal", this.colors["MenuItemNormal"] );
            this.pushColorChange( "ButtonHovered", this.colors["MenuItemHovered"] );
            this.pushColorChange( "ButtonPressed", this.colors["MenuItemPressed"] );
            let pressed = this.button( name, true, true, false );
            this.popColorChange( 3 );

            this.sameLine();
            this.activeWindow.cursor.x += 10;

            let expanded = false;

            if( pressed )
            {
                this.closeAllMenusWithParent( this.windows["__Popup__" + name] );
            }

            if( this.activeMenus )
            {
                if( pressed || this.activeMenus[name] !== undefined )
                {
                    this.closeAllMenusWithParent( this.activeWindow );
                    this.activeMenus[name] = new activeMenuEntry;
                    this.activeMenus[name].parentWindow = this.activeWindow;
                    
                    // Pop up a menu window below this.
                    let popupName = "__Popup__" + name;

                    // Clear all old popups.
                    this.FGDrawList.length = 0;
                    this.drawList = this.FGDrawList;

                    let x = menuItemPosition;
                    let y = this.activeWindow.position.y + this.activeWindow.size.y;

                    let size = vec2.getTemp( 0, 0 );
                    if( this.windows[popupName] )
                    {
                        size.setF32( this.windows[popupName].size.x, this.windows[popupName].size.y );
                    }
                    else
                    {
                        this.needsRefresh = true;
                    }

                    this.initWindow( popupName, false, vec2.getTemp( x, y ), size, true, true, false );

                    this.pushColorChange( "BG", this.colors["MenuPopupBG"] );
                    if( this.window( popupName ) )
                    {
                        this.activeWindow.cursor.y += this.popupPadding.y;
                        // Partial implementation of z-ordering, main menu is always in foreground.
                        this.windows[popupName].zOrder = 9999999;
                        expanded = true;
                    }
                    this.popColorChange();

                    this.windows[popupName].activeThisFrame = true;
                    this.windows[popupName].isMovable = false;
                    this.windows[popupName].saveState = false;
                    this.forceResize( this.activeWindow );

                    this.markStateDirty();
                }
            }

            this.drawList = this.BGDrawList;
            return expanded;
        }

        submenu(name: string)
        {
            this.previousMenu = this.activeWindow;

            if( this.activeWindow == null ) return;

            let menuItemPositionX = this.activeWindow.cursor.x + this.activeWindow.size.x;
            let menuItemPositionY = this.activeWindow.cursor.y;
            
            this.drawList = this.FGDrawList;

            // Resize the BG to fit the options... will have 1 frame lag.
            this.activeWindow.size.set( this.activeWindow.maxExtents.minus( this.activeWindow.position ) );
            this.activeWindow.size.x += this.padding.x + this.popupPadding.x;
            this.activeWindow.size.y += this.popupPadding.y;

            if( this.activeWindow.cursor.x === this.activeWindow.position.x )
            {
                this.activeWindow.cursor.x += this.popupPadding.x;
            }

            // Generate a label showing a small arrow at the end.
            // This will depend on the length of the longest button, based on the window size from previous frames.
            let buttonWidth = this.activeWindow.size.x - (this.padding.x*2 + this.popupPadding.x*2);
            let longestLabel = (buttonWidth - this.padding.x*2) / this.fontSize.x;
            let label = name;
            do
                label += " ";
            while( label.length < longestLabel - 1 )
            label += ">";

            // Show the button.
            this.pushColorChange( "ButtonNormal", this.colors["MenuItemNormal"] );
            this.pushColorChange( "ButtonHovered", this.colors["MenuItemHovered"] );
            this.pushColorChange( "ButtonPressed", this.colors["MenuItemPressed"] );
            let pressed = this.button( label, true, true, true );
            this.popColorChange( 3 );

            let expanded = false;

            if( this.activeMenus )
            {
                if( pressed || this.activeMenus[name] !== undefined )
                {
                    this.closeAllMenusWithParent( this.activeWindow );
                    this.activeMenus[name] = new activeMenuEntry;
                    this.activeMenus[name].parentWindow = this.activeWindow;

                    // Pop up a menu window below this.
                    let popupName = "__Popup__" + name;
                    
                    let x = menuItemPositionX;
                    let y = menuItemPositionY;
                    
                    let size = vec2.getTemp( 0, 0 );
                    if( this.windows[popupName] )
                    {
                        size.setF32( this.windows[popupName].size.x, this.windows[popupName].size.y );
                    }
                    else
                    {
                        this.needsRefresh = true;
                    }
                    
                    this.initWindow( popupName, false, vec2.getTemp( x, y ), size, true, true, false );
                    
                    this.pushColorChange( "BG", this.colors["MenuPopupBG"] );
                    if( this.window( popupName ) )
                    {
                        this.activeWindow.cursor.y += this.popupPadding.y;
                        this.activeWindow.parentWindow = this.previousMenu;
                        // Partial implementation of z-ordering, main menu is always in foreground.
                        this.windows[popupName].zOrder = 9999999;
                        expanded = true;
                    }
                    this.popColorChange();
                    
                    this.windows[popupName].activeThisFrame = true;
                    this.windows[popupName].isMovable = false;
                    this.windows[popupName].saveState = false;
                    this.forceResize( this.activeWindow );
                    
                    this.markStateDirty();
                }
            }

            this.drawList = this.BGDrawList;
            return expanded;
        }

        endSubmenu()
        {
            if( this.activeWindow )
            {
                this.activeWindow = this.activeWindow.parentWindow;
            }
        }

        menuItem(label: string)
        {
            this.drawList = this.FGDrawList;

            if( this.activeWindow == null ) return;

            if( this.activeWindow.cursor.x === this.activeWindow.position.x )
            {
                this.activeWindow.cursor.x += this.popupPadding.x;
            }
            this.pushColorChange( "ButtonNormal", this.colors["MenuItemNormal"] );
            this.pushColorChange( "ButtonHovered", this.colors["MenuItemHovered"] );
            this.pushColorChange( "ButtonPressed", this.colors["MenuItemPressed"] );
            let pressed = this.button( label, false, true, false );
            this.popColorChange( 3 );

            this.drawList = this.BGDrawList;

            // Resize the BG to fit the options... will have 1 frame lag.
            this.activeWindow.size.set( this.activeWindow.maxExtents.minus( this.activeWindow.position ) );
            this.activeWindow.size.x += this.padding.x + this.popupPadding.x;
            this.activeWindow.size.y += this.popupPadding.y;

            return pressed;
        }

        closeAllMenus()
        {
            this.activeMenus = {};
        }

        closeAllMenusWithParent(parentWindow: ImGuiWindow)
        {
            for( let key in this.activeMenus )
            {
                if( this.activeMenus[key].parentWindow === parentWindow )
                {
                    delete this.activeMenus[key];
                }
            }
        }

        // Return true is window is expanded.
        window(name: string)
        {
            let gl = this.gl;

            if( this.windows[name] === undefined )
            {
                let windowCount = Object.keys( this.windows ).length;

                this.windows[name] = new ImGuiWindow();
                this.windows[name].name = name;
                this.activeWindow = this.windows[name];
                
                this.activeWindow.position.setF32( 20 + 150*windowCount, 20 );
                this.activeWindow.cursor.set( this.activeWindow.position );
            }
            
            this.activeWindow = this.windows[name];
            this.activeWindow.activeThisFrame = true;

            // Partial implementation of z-ordering, windows are sorted by the order they're added.
            if( this.activeWindow.zOrder === -1 )
                this.activeWindow.zOrder = this.nextWindowZOrder++;

            // If the window is offscreen, force it back to 0,0.
            if( this.activeWindow.position.x + this.activeWindow.size.x < 0 || this.activeWindow.position.x >= this.canvas.width / this.scale ||
                this.activeWindow.position.y + this.activeWindow.size.y < 0 || this.activeWindow.position.y >= this.canvas.height / this.scale )
            {
                this.activeWindow.position.setF32( 0, 0 );
            }

            // If we're adding the window for the first time, add a title and BG.
            if( this.activeWindow.hasFrame === false )
            {
                let x = this.activeWindow.position.x;
                let y = this.activeWindow.position.y;
                
                let w = this.activeWindow.size.x;
                let h = this.activeWindow.size.y;

                this.activeWindow.rect.set( x, y, w, h );
            }
            else
            {
                if( this.activeWindow.cursor.y === this.activeWindow.position.y )
                {
                    let drawListItem = DrawListItem.getFromPool();

                    let x = this.activeWindow.position.x;
                    let y = this.activeWindow.position.y;

                    let w = this.activeWindow.size.x;

                    let titleH = 0;

                    // Draw the title box.
                    if( this.activeWindow.hasTitle )
                    {
                        titleH = this.fontSize.y + this.padding.y*2;
                        let h = titleH;
                        this.addBoxToDrawListItem( drawListItem, x,y,w,h, this.colors["Title"] );
                        let t = 1/this.scale; // Border thickness, essentially 1 pixel regardless of UI scale.
                        this.addBoxToDrawListItem( drawListItem, x,    y, t,h, this.colors["BGBorder"] ); // Border left.
                        this.addBoxToDrawListItem( drawListItem, x+w-t,y, t,h, this.colors["BGBorder"] ); // Border right.
                        this.addBoxToDrawListItem( drawListItem, x,y,     w,t, this.colors["BGBorder"] ); // Border top.
                        if( this.activeWindow.expanded === false )
                        {
                            this.addBoxToDrawListItem( drawListItem, x,y+h-t, w,t, this.colors["BGBorder"] ); // Border bottom.
                        }
                    }
                    this.activeWindow.rect.set( x, y, w, titleH );

                    if( this.activeWindow.expanded )
                    {
                        // Draw the BG box.
                        y += titleH;
                        let h = this.activeWindow.size.y - titleH;
                        this.addBoxToDrawListItem( drawListItem, x,y,w,h, this.colors["BG"] ); // BG filled.
                        let t = 1/this.scale; // Border thickness, essentially 1 pixel regardless of UI scale.
                        this.addBoxToDrawListItem( drawListItem, x,    y, t,h, this.colors["BGBorder"] ); // Border left.
                        this.addBoxToDrawListItem( drawListItem, x+w-t,y, t,h, this.colors["BGBorder"] ); // Border right.
                        if( this.activeWindow.hasTitle === false )
                            this.addBoxToDrawListItem( drawListItem, x,y,     w,t, this.colors["BGBorder"] ); // Border top.
                        this.addBoxToDrawListItem( drawListItem, x,y+h-t, w,t, this.colors["BGBorder"] ); // Border bottom.

                        // Define scissor rect, y is lower left.
                        let rx = this.activeWindow.position.x;
                        let ry = this.activeWindow.position.y;
                        let rw = this.activeWindow.size.x;
                        let rh = this.activeWindow.size.y;
                        this.activeWindow.rect.set( rx, ry, rw, rh );
                    }

                    // Adjust rect for main menu bar, if needed.
                    if( this.activeWindow.rect.y < this.mainMenuBarHeight )
                    {
                        this.activeWindow.rect.h -= this.mainMenuBarHeight - this.activeWindow.rect.y;
                        this.activeWindow.rect.y = this.mainMenuBarHeight;
                    }

                    drawListItem.set( gl.TRIANGLES, this.activeWindow.rect );
                    this.drawList.push( drawListItem );

                    if( this.activeWindow.hasTitle )
                    {
                        if( this.checkbox( "", this.activeWindow.expanded ) )
                        {
                            this.activeWindow.expanded = !this.activeWindow.expanded;
                        }

                        this.sameLine();
                        this.text( name );
                    }
                }

                if( this.activeWindow.hasTitle )
                {
                    // Button at bottom right to resize window.
                    if( this.activeWindow.expanded )
                    {
                        let x = this.activeWindow.cursor.x;
                        let y = this.activeWindow.cursor.y;
                        let rect = this.activeWindow.rect;
                        this.activeWindow.cursor.x = rect.x + rect.w - (this.padding.x + this.fontSize.x + this.padding.x)
                        this.activeWindow.cursor.y = rect.y + rect.h - (this.padding.y + this.fontSize.y + this.padding.y)
                        let oldMaxX = this.activeWindow.maxExtents.x;
                        let oldMaxY = this.activeWindow.maxExtents.y;
                        if( this.button( this.buttonString, true, false, false ) )
                        {
                            this.windowBeingResized = this.activeWindow;
                            this.windowResizeOffset.setF32( rect.x + rect.w - this.mousePosition.x, rect.y + rect.h - this.mousePosition.y );
                        }
                        this.activeWindow.maxExtents.setF32( oldMaxX, oldMaxY );
                        this.activeWindow.cursor.x = x;
                        this.activeWindow.cursor.y = y;
                    }
                }
            }

            return this.activeWindow.expanded;
        }

        forceResize(window: ImGuiWindow)
        {
            window.size.set( window.maxExtents.minus( window.position ) );
            window.size.x += this.padding.x;
            window.size.y += this.padding.y + this.fontSize.y + this.padding.y;
        }

        addBoxToDrawListItem(drawListItem: DrawListItem, x: number, y: number, w: number, h: number, color: color)
        {
            let numVerts = drawListItem.numVertComponents/8;
            drawListItem.pushVert( x+0,y+h,   0,0,   color.r,color.g,color.b,color.a );
            drawListItem.pushVert( x+0,y+0,   0,0,   color.r,color.g,color.b,color.a );
            drawListItem.pushVert( x+w,y+0,   0,0,   color.r,color.g,color.b,color.a );
            drawListItem.pushVert( x+w,y+h,   0,0,   color.r,color.g,color.b,color.a );
            drawListItem.pushIndex( numVerts+0 );
            drawListItem.pushIndex( numVerts+1 );
            drawListItem.pushIndex( numVerts+2 );
            drawListItem.pushIndex( numVerts+0 );
            drawListItem.pushIndex( numVerts+2 );
            drawListItem.pushIndex( numVerts+3 );
        }

        addStringToDrawList(str: string, x: number, y: number, rect: ImGuiRect | undefined = undefined)
        {
            if( this.font == null ) return;

            let gl = this.gl;

            let w = this.fontSize.x;
            let h = this.fontSize.y;

            let drawListItem = DrawListItem.getFromPool();

            let count = 0;
            for( let i=0; i<str.length; i++ )
            {
                let c = str.charCodeAt(i);
                if( c === 32 ) // Handle spaces.
                {
                    x += w;
                    continue;
                }
                if( c === 97+6 || c === 97+9 || c === 97+15 || c === 97+16 || c === 97+24 ) // g/j/p/q/y
                    y += 2;
                // Greek symbols.
                    if( c === 916 ) c = 130; // Δ
                else if( c === 952 ) c = 143; // θ
                else if( c === 969 ) c = 144; // ω
                else if( c > 150 )
                    console.log( "character not supported: " + c );
                c -= this.font.firstChar;
                let cx = Math.trunc( c % this.font.gridSize.x );
                let cy = Math.trunc( c / this.font.gridSize.x );

                let numVerts = drawListItem.numVertComponents/8;
                drawListItem.pushVert( x+0,y+h, this.font.stepU*(cx+0),               this.font.stepV*(cy+this.font.charH), 255,255,255,255 );
                drawListItem.pushVert( x+0,y+0, this.font.stepU*(cx+0),               this.font.stepV*(cy+0),               255,255,255,255 );
                drawListItem.pushVert( x+w,y+0, this.font.stepU*(cx+this.font.charW), this.font.stepV*(cy+0),               255,255,255,255 );
                drawListItem.pushVert( x+w,y+h, this.font.stepU*(cx+this.font.charW), this.font.stepV*(cy+this.font.charH), 255,255,255,255 );
                drawListItem.pushIndex( numVerts+0 );
                drawListItem.pushIndex( numVerts+1 );
                drawListItem.pushIndex( numVerts+2 );
                drawListItem.pushIndex( numVerts+0 );
                drawListItem.pushIndex( numVerts+2 );
                drawListItem.pushIndex( numVerts+3 );

                x += w;
                c += this.font.firstChar;
                if( c === 97+6 || c === 97+9 || c === 97+15 || c === 97+16 || c === 97+24 ) // g/j/p/q/y
                    y -= 2;
                count++;
            }

            if( rect === undefined )
                rect = this.largeRect;

            drawListItem.set( gl.TRIANGLES, rect );
            this.drawList.push( drawListItem );

            return vec2.getTemp( x, y );
        }

        text(str: string)
        {
            if( this.activeWindow == null ) return;

            // if( this.activeWindow.expanded == false )
            //     return;

            this.activeWindow.cursor.x += this.padding.x;
            this.activeWindow.cursor.y += this.padding.y;
            let x = this.activeWindow.cursor.x;
            let y = this.activeWindow.cursor.y;

            let h = this.fontSize.y;

            let pos = this.addStringToDrawList( str, x, y, this.activeWindow.rect );

            this.activeWindow.previousLineEndPosition.setF32( pos.x-this.padding.x, pos.y-this.padding.y );
            this.setIfBigger( this.activeWindow.maxExtents, pos.x, pos.y + this.fontSize.y + this.padding.y );

            this.activeWindow.cursor.setF32( pos.x, pos.y+h );
            this.activeWindow.cursor.y += this.padding.y;

            this.activeWindow.cursor.x = this.activeWindow.position.x;
        }

        button(label: string, returnTrueIfButtonIsHeldDown: boolean = false,
            allowPressIfMouseAlreadyHeld: boolean = false, returnTrueIfButtonIsHovered: boolean = false)
        {
            if( this.activeWindow == null ) return;
            // if( this.activeWindow.expanded == false )
            //     return;

            let gl = this.gl;

            let w = this.padding.x + label.length * this.fontSize.x + this.padding.x;
            let buttonTopPadding = 1;
            let h = buttonTopPadding + this.fontSize.y + this.padding.y;

            let drawListItem = DrawListItem.getFromPool();

            let x = this.activeWindow.cursor.x + this.padding.x;
            let y = this.activeWindow.cursor.y + buttonTopPadding;

            // Check if we're hovering over this button inside this window.
            let isHovering = false;
            let color = this.colors["ButtonNormal"];
            let rect = ImGuiRect.getFromPool( x, y, w, h );
            if( rect.contains( this.mousePosition ) )
            {
                if( this.activeWindow === this.windowHovered )
                {
                    isHovering = true;
                    color = this.colors["ButtonHovered"];

                    // Store if the button was clicked this frame.
                    if( (this.mouseButtons[0] === true && this.oldMouseButtons[0] === false) ||
                        (allowPressIfMouseAlreadyHeld && this.mouseButtons[0] === true) )
                    {
                        //if( this.buttonHeld != label && this.oldMouseButtons[0] == true )
                        //    debugger;

                        this.buttonHeld = label;
                    }

                    if( this.buttonHeld === label )
                    {
                        color = this.colors["ButtonPressed"];
                    }
                }
            }
            ImGuiRect.returnToPool( rect );

            this.addBoxToDrawListItem( drawListItem, x,y,w,h, color );

            drawListItem.set( gl.TRIANGLES, this.activeWindow.rect );
            this.drawList.push( drawListItem );

            this.activeWindow.cursor.x += this.padding.x;
            this.text( label );
            this.activeWindow.previousLineEndPosition.setF32( x + w, y - buttonTopPadding );
            this.setIfBigger( this.activeWindow.maxExtents, x + w, y + this.fontSize.y + this.padding.y );

            // Check if button was triggered.
            let triggered = false;

            // If this button is held down.
            if( this.buttonHeld === label )
            {
                this.isHoveringControl = true;

                if( isHovering )
                {
                    // If holding the button is considered "triggered".
                    if( returnTrueIfButtonIsHeldDown && this.buttonHeld === label )
                        triggered = true;

                    // If mouse released while button is held.
                    if( this.mouseButtons[0] === false && this.oldMouseButtons[0] === true )
                        triggered = true;
                }

                // If mouse button is up, stop considering this button as held down.
                if( this.mouseButtons[0] === false )
                    this.buttonHeld = null;
            }

            if( isHovering )
            {
                // If hovering over the button is considered "triggered".
                if( returnTrueIfButtonIsHovered )
                {
                    this.isHoveringControl = true;
                    triggered = true;
                }
            }

            if( triggered )
            {
                this.windowBeingMoved = null;
                //this.windowBeingResized = null;
                this.needsRefresh = true;
                return true;
            }

            return false;
        }

        checkbox(label: string, isChecked: boolean)
        {
            if( this.activeWindow == null ) return;

            // if( this.activeWindow.expanded == false )
            //     return;

            let gl = this.gl;

            this.text( label );
            this.sameLine();
            this.activeWindow.cursor.x += this.padding.x;

            let w = this.padding.x + this.fontSize.x + this.padding.x;
            let buttonTopPadding = 1;
            let h = buttonTopPadding + this.fontSize.y + this.padding.y;

            let drawListItem = DrawListItem.getFromPool();

            let x = this.activeWindow.cursor.x + this.padding.x;
            let y = this.activeWindow.cursor.y + buttonTopPadding;

            let isHovering = false;
            let color = this.colors["ButtonNormal"];
            let rect = ImGuiRect.getFromPool( x, y, w, h );
            if( rect.contains( this.mousePosition ) ) // is hovering.
            {
                if( this.activeWindow === this.windowHovered )
                {
                    isHovering = true;
                    color = this.colors["ButtonHovered"];

                    if( this.mouseButtons[0] === true ) // is pressing.
                    {
                        color = this.colors["ButtonPressed"];
                    }
                }
            }
            ImGuiRect.returnToPool( rect );

            this.addBoxToDrawListItem( drawListItem, x,y,w-1,h-1, color );

            if( isChecked )
            {
                color = this.colors["Checkbox"];
                this.addBoxToDrawListItem( drawListItem, x+2,y+2,w-5,h-5, color );
            }

            drawListItem.set( gl.TRIANGLES, this.activeWindow.rect );
            this.drawList.push( drawListItem );

            this.activeWindow.cursor.x += this.padding.x;
            this.activeWindow.previousLineEndPosition.setF32( x + w, y - buttonTopPadding );
            this.setIfBigger( this.activeWindow.maxExtents, x + w, y + this.fontSize.y + this.padding.y );
            this.activeWindow.cursor.x = this.activeWindow.position.x;
            this.activeWindow.cursor.y += this.padding.y + this.fontSize.y + this.padding.y;
            
            // Check if was pressed this frame.
            if( isHovering &&
                ( ( this.mouseButtons[0] === true && this.oldMouseButtons[0] === false ) ) )
            {
                this.isHoveringControl = true;
                this.windowBeingMoved = null;
                //this.windowBeingResized = null;
                this.needsRefresh = true;
                return true;
            }

            return false;
        }

        dragNumber(label: string, value: number, increment: number, decimalPlaces: number, minLimit?: number, maxLimit?: number): [number, boolean]
        {
            if( this.activeWindow == null ) return [0, false];

            // if( this.activeWindow.expanded == false )
            //     return;

            let gl = this.gl;

            let startValue = value;

            // Label and a bit of padding to it's right.
            this.text( label );
            this.sameLine();
            this.activeWindow.cursor.x += this.padding.x;
            let valueAsString = value.toFixed( decimalPlaces );

            // Vars.
            let drawListItem = DrawListItem.getFromPool();

            let buttonTopPadding = 1;
            let offsetx = this.activeWindow.cursor.x - this.activeWindow.position.x;
            let boxWidth = (this.activeWindow.size.x - offsetx) - this.padding.x*2;
            if( boxWidth < this.minDragBoxWidth )
                boxWidth = this.minDragBoxWidth;

            let x = this.activeWindow.cursor.x + this.padding.x;
            let y = this.activeWindow.cursor.y + buttonTopPadding;
            let w = boxWidth;
            let h = buttonTopPadding + this.fontSize.y + this.padding.y;

            let isHovering = false;

            // Draw background and determine if mouse if hovering over it.
            {
                let color = this.colors["ButtonNormal"];
                let rect = ImGuiRect.getFromPool( x, y, w, h );
                if( rect.contains( this.mousePosition ) ) // is hovering.
                {
                    if( this.activeWindow === this.windowHovered )
                    {
                        isHovering = true;
                    }
                }
                ImGuiRect.returnToPool( rect );

                if( this.controlInEditMode === label )
                {
                    color = this.colors["TextBoxSelected"];
                }
                else if( isHovering )
                {
                    color = this.colors["ButtonHovered"];

                    if( this.mouseButtons[0] === true ) // is pressing.
                    {
                        color = this.colors["ButtonPressed"];
                    }
                }

                this.addBoxToDrawListItem( drawListItem, x,y,w,h, color );
            }

            // Calculate some values for the text string.
            if( this.controlInEditMode === label )
            {
                valueAsString = this.activeControlTextBuffer.join( "" );
            }
            let textWidth = valueAsString.length*this.fontSize.x;
            let textStartPoint = boxWidth/2 - textWidth/2;

            // Draw a highlight around the selected text by drawing a second bg block.
            if( this.controlInEditMode === label && this.activeControlTextBufferSelected === true )
            {
                let h = buttonTopPadding + this.fontSize.y + this.padding.y;

                let color = this.colors["TextSelected"];

                this.addBoxToDrawListItem( drawListItem, x + textStartPoint,y,textWidth,h, color );
            }

            // Add BG verts to draw list.
            drawListItem.set( gl.TRIANGLES, this.activeWindow.rect );
            this.drawList.push( drawListItem );

            // Draw value as text.
            {
                this.activeWindow.cursor.x += textStartPoint;

                // Add a blinking cursor if we're editing this piece of text.
                if( this.controlInEditMode === label )
                {
                    if( this.currentTime % 1.0 < 0.5 )
                        valueAsString += String.fromCharCode( 31 );
                }

                // Draw text without affecting maxExtents.
                let oldMaxX = this.activeWindow.maxExtents.x;
                let oldMaxY = this.activeWindow.maxExtents.y;
                this.text( valueAsString );
                this.activeWindow.maxExtents.setF32( oldMaxX, oldMaxY );

                // Place cursor at end of text.
                this.sameLine();
            }

            // Adjust extents and cursor position.
            let minWidth = 40;
            if( minWidth < valueAsString.length*this.fontSize.x )
            {
                minWidth = valueAsString.length*this.fontSize.x + this.padding.x * 2;
            }

            this.activeWindow.cursor.x += this.padding.x;
            this.activeWindow.previousLineEndPosition.setF32( x + w, y - buttonTopPadding );
            this.setIfBigger( this.activeWindow.maxExtents, x + minWidth, y + this.fontSize.y + this.padding.y );
            this.activeWindow.cursor.x = this.activeWindow.position.x;
            this.activeWindow.cursor.y += this.padding.y + this.fontSize.y + this.padding.y;

            // Check if the control was pressed this frame.
            if( isHovering &&
                ( ( this.mouseButtons[0] === true && this.oldMouseButtons[0] === false ) ) )
            {
                this.activeControl = label;
                this.isHoveringControl = true;
                this.windowBeingMoved = null;
                //this.windowBeingResized = null;
            }

            let doneWithEditMode = false;

            // If we're not hovering the control and mouse is clicked, exit edit mode.
            if( isHovering === false )
            {
                if( this.mouseButtons[0] === true && this.oldMouseButtons[0] === false )
                    doneWithEditMode = true;
            }

            // If hovering and double-clicked, switch to edit mode.
            if( isHovering && this.mouseButtons[0] === true && this.oldMouseButtons[0] === false )
            {
                if( this.controlInEditMode !== label && this.mouseDoubleClickedThisFrame[0] )
                {
                    this.controlInEditMode = label;
                    this.activeControlTextBuffer = valueAsString.split( "" );
                    this.activeControlTextBufferSelected = true;
                }
            }

            // If this control is in edit mode, empty the unusedKeyBuffer into it.
            if( this.controlInEditMode === label )
            {
                for( let i=0; i<this.unusedKeyBuffer.length; i++ )
                {
                    if( this.unusedKeyBuffer[i] === "Backspace" )
                    {
                        if( this.activeControlTextBufferSelected )
                        {
                            this.activeControlTextBuffer.length = 0;
                            this.activeControlTextBufferSelected = false;
                        }

                        if( this.activeControlTextBuffer.length > 0 )
                        {
                            this.activeControlTextBuffer.length = this.activeControlTextBuffer.length-1;
                        }
                    }
                    else if( this.unusedKeyBuffer[i] === "Enter" )
                    {
                        doneWithEditMode = true;
                    }
                    else if( this.unusedKeyBuffer[i].length === 1 )
                    {
                        if( this.activeControlTextBufferSelected )
                        {
                            this.activeControlTextBuffer.length = 0;
                            this.activeControlTextBufferSelected = false;
                        }

                        this.activeControlTextBuffer.push( this.unusedKeyBuffer[i] );
                    }
                    else
                    {
                        this.activeControlTextBufferSelected = false;
                    }
                }

                if( this.activeControlTextBuffer.length > 0 )
                {
                    let string = this.activeControlTextBuffer.join( "" );
                    let newValue = Number( string );
                    if( isNaN( newValue ) === false )
                        value = newValue;
                }

                if( doneWithEditMode )
                {
                    this.controlInEditMode = null;
                    this.activeControlTextBuffer.length = 0;
                }
            }

            // If mouse held.
            if( this.activeControl === label &&
                this.mouseButtons[0] === true && this.oldMouseButtons[0] === true )
            {
                value += this.mouseChangeUnscaled.x * increment;
            }

            if( minLimit !== undefined ) { if( value < minLimit ) value = minLimit; }
            if( maxLimit !== undefined ) { if( value > maxLimit ) value = maxLimit; }

            let changed = false;
            if( value !== startValue )
            {
                changed = true;
                this.needsRefresh = true;
            }

            return [value, changed];
        }
    }

    class ImGuiWindow
    {
        name: string;
        position: vec2;
        size: vec2;
        zOrder: number;
        
        activeThisFrame: boolean;
        cursor: vec2;
        previousLineEndPosition: vec2;
        rect: ImGuiRect;

        expanded: boolean;
        maxExtents: vec2;

        saveState: boolean;

        hasTitle: boolean;
        hasFrame: boolean;
        isMovable: boolean;
        takesInput: boolean;

        parentWindow: ImGuiWindow | null = null;

        constructor()
        {
            this.name = "";
            this.position = new vec2( 0, 0 );
            this.size = new vec2( 0, 0 );
            this.zOrder = -1;
        
            this.activeThisFrame = false;
            this.cursor = new vec2(0);
            this.previousLineEndPosition = new vec2(0);
            this.rect = new ImGuiRect(0,0,0,0);

            this.expanded = true;
            this.maxExtents = new vec2(0); // Stores the lower right screen x/y of the window (not just the biggest size).

            this.saveState = true;

            this.hasTitle = true;
            this.hasFrame = true;
            this.isMovable = true;
            this.takesInput = true;
        }
    }

    class DrawListItem
    {
        primitiveType: number;
        rect: ImGuiRect;

        vertComponents: number[];
        indices: number[];
        numVertComponents: number;
        numIndices: number;

        //static pool = new Pool( DrawListItem, 100, true );
        static getFromPool(primitiveType = null, rect = null)
        {
            let obj = DrawListItem_pool.getFromPool();
            obj.clear();
            if( primitiveType !== null )
                obj.set( primitiveType, rect ); 
            return obj;
        }
        static returnToPool(obj: DrawListItem) { return DrawListItem_pool.returnToPool( obj ); }

        constructor(primitiveType: number, rect: ImGuiRect)
        {
            if( primitiveType !== undefined )
                this.set( primitiveType, rect );

            this.primitiveType = 0;
            this.rect = new ImGuiRect(0,0,0,0);

            // Set verts and indices sizes to the worst case imgui currently needs.
            this.vertComponents = new Array( 56 * 8 );
            this.indices = new Array( 80 );
            this.numVertComponents = 0;
            this.numIndices = 0;
        }

        set(primitiveType: number, rect: ImGuiRect)
        {
            this.primitiveType = primitiveType;
            this.rect = rect;
        }

        clear()
        {
            this.numVertComponents = 0;
            this.numIndices = 0;
        }

        pushVert(x: number, y: number, u: number, v: number, r: number, g: number, b: number, a: number)
        {
            let spaceNeeded = (this.numVertComponents + 8) - this.vertComponents.length;
            //if( spaceNeeded > 0 )
            //{
            //    console.log( "Increasing drawListItem's verts by " + spaceNeeded );
            //}
            while( spaceNeeded > 0 )
            {
                this.vertComponents.push(0);
                spaceNeeded--;
            }

            this.vertComponents[this.numVertComponents+0] = x;
            this.vertComponents[this.numVertComponents+1] = y;
            this.vertComponents[this.numVertComponents+2] = u;
            this.vertComponents[this.numVertComponents+3] = v;
            this.vertComponents[this.numVertComponents+4] = r;
            this.vertComponents[this.numVertComponents+5] = g;
            this.vertComponents[this.numVertComponents+6] = b;
            this.vertComponents[this.numVertComponents+7] = a;

            this.numVertComponents += 8;
        }

        pushIndex(index: number)
        {
            if( this.numIndices === this.indices.length )
            {
                //console.log( "Increasing drawListItem's indices by " + 1 );
                this.indices.push( index );
            }
            else
            {
                this.indices[this.numIndices] = index;
            }
            this.numIndices++;
        }
    }

    class ImGuiRect
    {
        x: number;
        y: number;
        w: number;
        h: number;

        //static pool = new Pool( ImGuiRect, 1000, true );
        static getFromPool(x: number, y: number, w: number, h: number)
        {
            let obj = ImGuiRect_pool.getFromPool();
            obj.set(x,y,w,h); 
            return obj;
        }
        static returnToPool(obj: ImGuiRect) { return ImGuiRect_pool.returnToPool( obj ); }

        constructor(x: number, y: number, w: number, h: number)
        {
            this.x = x;
            this.y = y;
            this.w = w;
            this.h = h;
        }

        set(x: number, y: number, w: number, h: number)
        {
            this.x = x;
            this.y = y;
            this.w = w;
            this.h = h;
        }

        contains(pos: vec2)
        {
            if( pos.x > this.x && pos.x < this.x + this.w &&
                pos.y > this.y && pos.y < this.y + this.h )
            {
                return true;
            }
            
            return false;
        }
    }

    class FontDef
    {
        texture: Texture;
        firstChar: number;
        gridSize: vec2;
        stepU: number;
        stepV: number;
        charW: number;
        charH: number;

        constructor(texture: Texture, firstChar: number, charSize: vec2, gridSize: vec2, padding: vec2, textureRes: vec2)
        {
            this.texture = texture;
            this.firstChar = firstChar;
            this.gridSize = gridSize;
            this.stepU = (charSize.x+padding.x) / textureRes.x;
            this.stepV = (charSize.y+padding.y) / textureRes.y;
            this.charW = charSize.x / (charSize.x+padding.x);
            this.charH = charSize.y / (charSize.y+padding.y);
        }
    }

    let DrawListItem_pool = new Pool( DrawListItem, 100, true );
    let ImGuiRect_pool = new Pool( ImGuiRect, 1000, true );
}
